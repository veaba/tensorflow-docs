(window.webpackJsonp=window.webpackJsonp||[]).push([[2009],{2197:function(a,t,e){"use strict";e.r(t);var n=e(0),i=Object(n.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("Returns the batched diagonal part of a batched tensor.")]),a._v(" "),e("h3",{attrs:{id:"aliases"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[a._v("#")]),a._v(" Aliases:")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("tf.compat.v1.linalg.diag_part")])]),a._v(" "),e("li",[e("code",[a._v("tf.compat.v1.matrix_diag_part")])]),a._v(" "),e("li",[e("code",[a._v("tf.compat.v2.linalg.diag_part")])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" tf.linalg.diag_part(\n    input,\n    name='diag_part',\n    k=0,\n    padding_value=0\n)\n")])])]),e("p",[a._v("Returns a tensor with the k[0]-th to k[1]-th diagonals of the batched input.")]),a._v(" "),e("p",[a._v("Assume input has r dimensions [I, J, ..., L, M, N]. Let max_diag_len be the maximum length among all diagonals to be extracted, max_diag_len = min(M + min(k[1], 0), N + min(-k[0], 0)) Let num_diags be the number of diagonals to extract, num_diags = k[1] - k[0] + 1.")]),a._v(" "),e("p",[a._v("If num_diags == 1, the output tensor is of rank r - 1 with shape [I, J, ..., L, max_diag_len] and values:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" diagonal[i, j, ..., l, n]\n  = input[i, j, ..., l, n+y, n+x] ; when 0 <= n-y < M and 0 <= n-x < N,\n    0                             ; otherwise.\n")])])]),e("p",[a._v("where y = max(-k[1], 0), x = max(k[1], 0).")]),a._v(" "),e("p",[a._v("Otherwise, the output tensor has rank r with dimensions [I, J, ..., L, num_diags, max_diag_len] with values:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" diagonal[i, j, ..., l, m, n]\n  = input[i, j, ..., l, n+y, n+x] ; when 0 <= n-y < M and 0 <= n-x < N,\n    0                             ; otherwise.\n")])])]),e("p",[a._v("where d = k[1] - m, y = max(-d, 0), and x = max(d, 0).")]),a._v(" "),e("p",[a._v("The input must be at least a matrix.")]),a._v(" "),e("h4",{attrs:{id:"for-example"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#for-example","aria-hidden":"true"}},[a._v("#")]),a._v(" For example:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" input = np.array([[[1, 2, 3, 4],  # Input shape: (2, 3, 4)\n                   [5, 6, 7, 8],\n                   [9, 8, 7, 6]],\n                  [[5, 4, 3, 2],\n                   [1, 2, 3, 4],\n                   [5, 6, 7, 8]]])\n\n# A main diagonal from each batch.\ntf.matrix_diag_part(input) ==> [[1, 6, 7],  # Output shape: (2, 3)\n                                [5, 2, 7]]\n\n# A superdiagonal from each batch.\ntf.matrix_diag_part(input, k = 1)\n  ==> [[2, 7, 6],  # Output shape: (2, 3)\n       [4, 3, 8]]\n\n# A tridiagonal band from each batch.\ntf.matrix_diag_part(input, k = (-1, 1))\n  ==> [[[2, 7, 6],  # Output shape: (2, 3, 3)\n        [1, 6, 7],\n        [5, 8, 0]],\n       [[4, 3, 8],\n        [5, 2, 7],\n        [1, 6, 0]]]\n\n# Padding = 9\ntf.matrix_diag_part(input, k = (1, 3), padding = 9)\n  ==> [[[4, 9, 9],  # Output shape: (2, 3, 3)\n        [3, 8, 9],\n        [2, 7, 6]],\n       [[2, 9, 9],\n        [3, 4, 9],\n        [4, 3, 8]]]\n")])])]),e("h4",{attrs:{id:"args"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[a._v("#")]),a._v(" Args:")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("input")]),a._v(": A "),e("code",[a._v("Tensor")]),a._v(" with "),e("code",[a._v("rank k >= 2")]),a._v(".")]),a._v(" "),e("li",[e("code",[a._v("name")]),a._v(": A "),e("code",[a._v("name")]),a._v(" for the operation (optional).")]),a._v(" "),e("li",[e("code",[a._v("k")]),a._v(": Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main diagonal, and negative value means subdiagonals. "),e("code",[a._v("k")]),a._v(" can be a single integer (for a single diagonal) or a pair of integers specifying the low and high ends of a matrix band. "),e("code",[a._v("k")]),a._v("[0] must not be larger than "),e("code",[a._v("k")]),a._v("[1].")]),a._v(" "),e("li",[e("code",[a._v("padding_value")]),a._v(": The value to fill the area outside the specified diagonal band with. Default is 0.")])]),a._v(" "),e("h4",{attrs:{id:"returns"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[a._v("#")]),a._v(" Returns:")]),a._v(" "),e("p",[a._v("A Tensor containing diagonals of input. Has the same type as input.")])])}),[],!1,null,null,null);t.default=i.exports}}]);