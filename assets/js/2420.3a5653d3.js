(window.webpackJsonp=window.webpackJsonp||[]).push([[2420],{2608:function(e,t,a){"use strict";a.r(t);var s=a(0),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Asserts that two GraphDefs are (mostly) the same.")]),e._v(" "),a("h3",{attrs:{id:"aliases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("tf.compat.v2.test.assert_equal_graph_def")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" tf.test.assert_equal_graph_def(\n    expected,\n    actual\n)\n")])])]),a("p",[e._v("Compares two GraphDef protos for equality, ignoring versions and ordering of nodes, attrs, and control inputs. Node names are used to match up nodes between the graphs, so the naming of nodes must be consistent. This function ignores randomized attribute values that may appear in V2 checkpoints.")]),e._v(" "),a("h4",{attrs:{id:"args"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("expected")]),e._v(": The "),a("code",[e._v("GraphDef")]),e._v(" we "),a("code",[e._v("expected")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("actual")]),e._v(": The "),a("code",[e._v("GraphDef")]),e._v(" we have.")])]),e._v(" "),a("h4",{attrs:{id:"raises"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("AssertionError")]),e._v(": If the "),a("code",[e._v("GraphDef")]),e._v("s do not match.")]),e._v(" "),a("li",[a("code",[e._v("TypeError")]),e._v(": If either argument is not a "),a("code",[e._v("GraphDef")]),e._v(".")])])])}),[],!1,null,null,null);t.default=r.exports}}]);