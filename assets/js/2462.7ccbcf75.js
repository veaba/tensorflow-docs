(window.webpackJsonp=window.webpackJsonp||[]).push([[2462],{2650:function(e,t,a){"use strict";a.r(t);var n=a(0),i=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[a("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/function",target:"_blank",rel:"noopener noreferrer"}},[e._v("tf.function"),a("OutboundLink")],1),e._v("Enable mixed precision in s via a graph rewrite.")]),e._v(" "),a("h3",{attrs:{id:"aliases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("tf.compat.v2.train.experimental.enable_mixed_precision_graph_rewrite")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" tf.train.experimental.enable_mixed_precision_graph_rewrite(\n    opt,\n    loss_scale='dynamic'\n)\n")])])]),a("p",[a("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/function",target:"_blank",rel:"noopener noreferrer"}},[e._v("tf.function"),a("OutboundLink")],1),e._v("Mixed precision is the use of both float16 and float32 when training a model, and is used to make the model run faster. This function will use mixed precision to speed up the execution time of s when run on a GPU. It does this by changing the dtype of certain operations in the function's graph from float32 to float16.")]),e._v(" "),a("p",[e._v("This function additionally wraps an Optimizer with a LossScaleOptimizer, which is required to prevent underflow in the float16 tensors during the backwards pass. An optimizer must be passed to this function, which will then be wrapped to use loss scaling.\n"),a("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/GradientTape",target:"_blank",rel:"noopener noreferrer"}},[e._v("tf.GradientTape"),a("OutboundLink")],1),e._v("When this function is used, gradients should only be computed and applied with the returned optimizer through opt.minimize(), and not with a . This is because the returned optimizer will apply loss scaling, and  will not. If you do use a , your model may train to a worse quality.")]),e._v(" "),a("p",[e._v("Currently, mixed precision is only enabled on Volta GPUs and above. TPU support is coming soon. CPUs are not supported, as CPUs do not run float16 operations faster than float32 operations.")]),e._v(" "),a("p",[e._v("WARNING: This rewrite silently affects the entire model and can have unintended consequences. One example: If a NaN occurs during dynamic loss scaling, the data for the batch is silently dropped while the LossScaleOptimizer attempts to find the appropriate scaling value on the next batch.")]),e._v(" "),a("h4",{attrs:{id:"args"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("opt")]),e._v(": An instance of a "),a("code",[e._v("tf.keras.optimizers.Optimizer")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("loss_scale")]),e._v(': Either an int/float, the string "dynamic", or an instance of a '),a("code",[e._v("tf.train.experimental.LossScale")]),e._v('. The loss scale to use. It is recommended to keep this as its default value of "dynamic".')])]),e._v(" "),a("h4",{attrs:{id:"returns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),a("p",[e._v("A version of opt that will use loss scaling to prevent underflow.")])])}),[],!1,null,null,null);t.default=i.exports}}]);