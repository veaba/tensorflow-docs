(window.webpackJsonp=window.webpackJsonp||[]).push([[669],{857:function(e,a,t){"use strict";t.r(a);var s=t(0),o=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Computes sigmoid cross entropy given logits.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" tf.compat.v1.nn.sigmoid_cross_entropy_with_logits(\n    _sentinel=None,\n    labels=None,\n    logits=None,\n    name=None\n)\n")])])]),t("p",[e._v("Measures the probability error in discrete classification tasks in which each class is independent and not mutually exclusive. For instance, one could perform multilabel classification where a picture can contain both an elephant and a dog at the same time.")]),e._v(" "),t("p",[e._v("For brevity, let x = logits, z = labels. The logistic loss is")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("   z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))\n= z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))\n= z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))\n= z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))\n= (1 - z) * x + log(1 + exp(-x))\n= x - x * z + log(1 + exp(-x))\n")])])]),t("p",[e._v("For x < 0, to avoid overflow in exp(-x), we reformulate the above")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("   x - x * z + log(1 + exp(-x))\n= log(exp(x)) - x * z + log(1 + exp(-x))\n= - x * z + log(1 + exp(x))\n")])])]),t("p",[e._v("Hence, to ensure stability and avoid overflow, the implementation uses this equivalent formulation")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" max(x, 0) - x * z + log(1 + exp(-abs(x)))\n")])])]),t("p",[e._v("logits and labels must have the same type and shape.")]),e._v(" "),t("h4",{attrs:{id:"args"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("_sentinel")]),e._v(": Used to prevent positional parameters. Internal, do not use.")]),e._v(" "),t("li",[t("code",[e._v("labels")]),e._v(": A "),t("code",[e._v("Tensor")]),e._v(" of the same type and shape as "),t("code",[e._v("logits")]),e._v(".")]),e._v(" "),t("li",[t("code",[e._v("logits")]),e._v(": A "),t("code",[e._v("Tensor")]),e._v(" of type "),t("code",[e._v("float32")]),e._v(" or "),t("code",[e._v("float64")]),e._v(".")]),e._v(" "),t("li",[t("code",[e._v("name")]),e._v(": A "),t("code",[e._v("name")]),e._v(" for the operation (optional).")])]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),t("p",[e._v("A Tensor of the same shape as logits with the componentwise logistic losses.")]),e._v(" "),t("h4",{attrs:{id:"raises"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("ValueError")]),e._v(": If "),t("code",[e._v("logits")]),e._v(" and "),t("code",[e._v("labels")]),e._v(" do not have the same shape.")])])])}),[],!1,null,null,null);a.default=o.exports}}]);