(window.webpackJsonp=window.webpackJsonp||[]).push([[2362],{2550:function(e,t,s){"use strict";s.r(t);var a=s(0),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("Converts a SparseTensor of ids into a dense bool indicator tensor.")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("tf.compat.v1.sparse.to_indicator")])]),e._v(" "),s("li",[s("code",[e._v("tf.compat.v1.sparse_to_indicator")])]),e._v(" "),s("li",[s("code",[e._v("tf.compat.v2.sparse.to_indicator")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" tf.sparse.to_indicator(\n    sp_input,\n    vocab_size,\n    name=None\n)\n")])])]),s("p",[e._v("The last dimension of sp_input.indices is discarded and replaced with the values of sp_input. If sp_input.dense_shape = [D0, D1, ..., Dn, K], then output.shape = [D0, D1, ..., Dn, vocab_size], where")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" output[d_0, d_1, ..., d_n, sp_input[d_0, d_1, ..., d_n, k]] = True\n")])])]),s("p",[e._v("and False elsewhere in output.")]),e._v(" "),s("p",[e._v("For example, if sp_input.dense_shape = [2, 3, 4] with non-empty values:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" [0, 0, 0]: 0\n[0, 1, 0]: 10\n[1, 0, 3]: 103\n[1, 1, 1]: 150\n[1, 1, 2]: 149\n[1, 1, 3]: 150\n[1, 2, 1]: 121\n")])])]),s("p",[e._v("and vocab_size = 200, then the output will be a [2, 3, 200] dense bool tensor with False everywhere except at positions")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" (0, 0, 0), (0, 1, 10), (1, 0, 103), (1, 1, 149), (1, 1, 150),\n(1, 2, 121).\n")])])]),s("p",[e._v("Note that repeats are allowed in the input SparseTensor. This op is useful for converting SparseTensors into dense formats for compatibility with ops that expect dense tensors.")]),e._v(" "),s("p",[e._v("The input SparseTensor must be in row-major order.")]),e._v(" "),s("h4",{attrs:{id:"args"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("sp_input")]),e._v(": A "),s("code",[e._v("SparseTensor")]),e._v(" with "),s("code",[e._v("values")]),e._v(" property of type "),s("code",[e._v("int32")]),e._v(" or "),s("code",[e._v("int64")]),e._v(".")]),e._v(" "),s("li",[s("code",[e._v("vocab_size")]),e._v(": A scalar "),s("code",[e._v("int64")]),e._v(" Tensor (or Python int) containing the new size of the last dimension, all(0 <= "),s("code",[e._v("sp_input")]),e._v("."),s("code",[e._v("values")]),e._v(" < "),s("code",[e._v("vocab_size")]),e._v(").")]),e._v(" "),s("li",[s("code",[e._v("name")]),e._v(": A "),s("code",[e._v("name")]),e._v(" prefix for the returned tensors (optional)")])]),e._v(" "),s("h4",{attrs:{id:"returns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),s("p",[e._v("A dense bool indicator tensor representing the indices with specified value.")]),e._v(" "),s("h4",{attrs:{id:"raises"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("TypeError")]),e._v(": If "),s("code",[e._v("sp_input")]),e._v(" is not a "),s("code",[e._v("SparseTensor")]),e._v(".")])])])}),[],!1,null,null,null);t.default=n.exports}}]);