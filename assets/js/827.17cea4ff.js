(window.webpackJsonp=window.webpackJsonp||[]).push([[827],{1015:function(e,a,t){"use strict";t.r(a);var s=t(0),n=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Computes and returns the theoretical and numerical Jacobian. (deprecated)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" tf.compat.v1.test.compute_gradient(\n    x,\n    x_shape,\n    y,\n    y_shape,\n    x_init_value=None,\n    delta=0.001,\n    init_targets=None,\n    extra_feed_dict=None\n)\n")])])]),t("p",[e._v("If x or y is complex, the Jacobian will still be real but the corresponding Jacobian dimension(s) will be twice as large. This is required even if both input and output is complex since TensorFlow graphs are not necessarily holomorphic, and may have gradients not expressible as complex numbers. For example, if x is complex with shape [m] and y is complex with shape [n], each Jacobian J will have shape [m * 2, n * 2] with")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" J[:m, :n] = d(Re y)/d(Re x)\nJ[:m, n:] = d(Im y)/d(Re x)\nJ[m:, :n] = d(Re y)/d(Im x)\nJ[m:, n:] = d(Im y)/d(Im x)\n")])])]),t("h4",{attrs:{id:"args"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("x")]),e._v(": a tensor or list of tensors")]),e._v(" "),t("li",[t("code",[e._v("x")]),e._v("_shape: the dimensions of "),t("code",[e._v("x")]),e._v(" as a tuple or an array of ints. If "),t("code",[e._v("x")]),e._v(" is a list, then this is the list of shapes.")]),e._v(" "),t("li",[t("code",[e._v("y")]),e._v(": a tensor")]),e._v(" "),t("li",[t("code",[e._v("y")]),e._v("_shape: the dimensions of "),t("code",[e._v("y")]),e._v(" as a tuple or an arra"),t("code",[e._v("y")]),e._v(" of ints.")]),e._v(" "),t("li",[t("code",[e._v("x")]),e._v("_init_value: (optional) a nump"),t("code",[e._v("y")]),e._v(" arra"),t("code",[e._v("y")]),e._v(' of the same shape as "'),t("code",[e._v("x")]),e._v('" representing the initial value of '),t("code",[e._v("x")]),e._v(". If "),t("code",[e._v("x")]),e._v(" is a list, this should be a list of nump"),t("code",[e._v("y")]),e._v(" arra"),t("code",[e._v("y")]),e._v("s. If this is none, the function will pick a random tensor as the initial value.")]),e._v(" "),t("li",[t("code",[e._v("delta")]),e._v(": (optional) the amount of perturbation.")]),e._v(" "),t("li",[t("code",[e._v("init_targets")]),e._v(": list of targets to run to initialize model params.")]),e._v(" "),t("li",[t("code",[e._v("extra_feed_dict")]),e._v(": dict that allows fi"),t("code",[e._v("x")]),e._v("ing specified tensor values during the Jacobian calculation.")])]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),t("p",[e._v('Two 2-d numpy arrays representing the theoretical and numerical Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns where "x_size" is the number of elements in x and "y_size" is the number of elements in y. If x is a list, returns a list of two numpy arrays.')])])}),[],!1,null,null,null);a.default=n.exports}}]);