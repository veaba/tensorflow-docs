(window.webpackJsonp=window.webpackJsonp||[]).push([[2024],{2215:function(a,e,n){"use strict";n.r(e);var t=n(0),i=Object(t.a)({},(function(){var a=this,e=a.$createElement,n=a._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("p",[a._v("Returns a batched matrix tensor with new batched diagonal values.")]),a._v(" "),n("h3",{attrs:{id:"aliases"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[a._v("#")]),a._v(" Aliases:")]),a._v(" "),n("ul",[n("li",[n("code",[a._v("tf.compat.v1.linalg.set_diag")])]),a._v(" "),n("li",[n("code",[a._v("tf.compat.v1.matrix_set_diag")])]),a._v(" "),n("li",[n("code",[a._v("tf.compat.v2.linalg.set_diag")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v(" tf.linalg.set_diag(\n    input,\n    diagonal,\n    name='set_diag',\n    k=0\n)\n")])])]),n("p",[a._v("Given input and diagonal, this operation returns a tensor with the same shape and values as input, except for the specified diagonals of the innermost matrices. These will be overwritten by the values in diagonal.")]),a._v(" "),n("p",[a._v("input has r+1 dimensions [I, J, ..., L, M, N]. When k is scalar or k[0] == k[1], diagonal has r dimensions [I, J, ..., L, max_diag_len]. Otherwise, it has r+1 dimensions [I, J, ..., L, num_diags, max_diag_len]. num_diags is the number of diagonals, num_diags = k[1] - k[0] + 1. max_diag_len is the longest diagonal in the range [k[0], k[1]], max_diag_len = min(M + min(k[1], 0), N + min(-k[0], 0))")]),a._v(" "),n("p",[a._v("The output is a tensor of rank k+1 with dimensions [I, J, ..., L, M, N]. If k is scalar or k[0] == k[1]:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v(" output[i, j, ..., l, m, n]\n  = diagonal[i, j, ..., l, n-max(k[1], 0)] ; if n - m == k[1]\n    output[i, j, ..., l, m, n]             ; otherwise\n")])])]),n("p",[a._v("Otherwise,")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v(" output[i, j, ..., l, m, n]\n  = diagonal[i, j, ..., l, k[1]-d, n-max(d, 0)] ; if d_lower <= d <= d_upper\n    input[i, j, ..., l, m, n]                   ; otherwise\n")])])]),n("p",[a._v("where d = n - m")]),a._v(" "),n("h4",{attrs:{id:"for-example"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#for-example","aria-hidden":"true"}},[a._v("#")]),a._v(" For example:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v(" # The main diagonal.\ninput = np.array([[[7, 7, 7, 7],              # Input shape: (2, 3, 4)\n                   [7, 7, 7, 7],\n                   [7, 7, 7, 7]],\n                  [[7, 7, 7, 7],\n                   [7, 7, 7, 7],\n                   [7, 7, 7, 7]]])\ndiagonal = np.array([[1, 2, 3],               # Diagonal shape: (2, 3)\n                     [4, 5, 6]])\ntf.matrix_diag(diagonal) ==> [[[1, 7, 7, 7],  # Output shape: (2, 3, 4)\n                               [7, 2, 7, 7],\n                               [7, 7, 3, 7]],\n                              [[4, 7, 7, 7],\n                               [7, 5, 7, 7],\n                               [7, 7, 6, 7]]]\n\n# A superdiagonal (per batch).\ntf.matrix_diag(diagonal, k = 1)\n  ==> [[[7, 1, 7, 7],  # Output shape: (2, 3, 4)\n        [7, 7, 2, 7],\n        [7, 7, 7, 3]],\n       [[7, 4, 7, 7],\n        [7, 7, 5, 7],\n        [7, 7, 7, 6]]]\n\n# A band of diagonals.\ndiagonals = np.array([[[1, 2, 3],  # Diagonal shape: (2, 2, 3)\n                       [4, 5, 0]],\n                      [[6, 1, 2],\n                       [3, 4, 0]]])\ntf.matrix_diag(diagonals, k = (-1, 0))\n  ==> [[[1, 7, 7, 7],  # Output shape: (2, 3, 4)\n        [4, 2, 7, 7],\n        [0, 5, 3, 7]],\n       [[6, 7, 7, 7],\n        [3, 1, 7, 7],\n        [7, 4, 2, 7]]]\n")])])]),n("h4",{attrs:{id:"args"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[a._v("#")]),a._v(" Args:")]),a._v(" "),n("ul",[n("li",[n("code",[a._v("input")]),a._v(": A "),n("code",[a._v("Tensor")]),a._v(" with rank k + 1, where "),n("code",[a._v("k >= 1")]),a._v(".")]),a._v(" "),n("li",[n("code",[a._v("diagonal")]),a._v(": A "),n("code",[a._v("Tensor")]),a._v(" with ran"),n("code",[a._v("k")]),a._v(" "),n("code",[a._v("k")]),a._v(", when "),n("code",[a._v("d_lower == d_upper")]),a._v(", or "),n("code",[a._v("k")]),a._v(" + 1, otherwise. "),n("code",[a._v("k >= 1")]),a._v(".")]),a._v(" "),n("li",[n("code",[a._v("name")]),a._v(": A "),n("code",[a._v("name")]),a._v(" for the operation (optional).")]),a._v(" "),n("li",[n("code",[a._v("k")]),a._v(": Diagonal offset(s). Positive value means super"),n("code",[a._v("diagonal")]),a._v(", 0 refers to the main "),n("code",[a._v("diagonal")]),a._v(", and negative value means sub"),n("code",[a._v("diagonal")]),a._v("s. "),n("code",[a._v("k")]),a._v(" can be a single integer (for a single "),n("code",[a._v("diagonal")]),a._v(") or a pair of integers specifying the low and high ends of a matrix band. "),n("code",[a._v("k")]),a._v("[0] must not be larger than "),n("code",[a._v("k")]),a._v("[1].")])])])}),[],!1,null,null,null);e.default=i.exports}}]);