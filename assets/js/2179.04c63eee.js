(window.webpackJsonp=window.webpackJsonp||[]).push([[2179],{2367:function(e,t,s){"use strict";s.r(t);var a=s(0),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("Returns a given flattened sequence packed into a given structure.")]),e._v(" "),s("h3",{attrs:{id:"aliases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("tf.compat.v1.nest.pack_sequence_as")])]),e._v(" "),s("li",[s("code",[e._v("tf.compat.v2.nest.pack_sequence_as")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" tf.nest.pack_sequence_as(\n    structure,\n    flat_sequence,\n    expand_composites=False\n)\n")])])]),s("p",[e._v("If structure is a scalar, flat_sequence must be a single-element list; in this case the return value is flat_sequence[0].")]),e._v(" "),s("p",[e._v("If structure is or contains a dict instance, the keys will be sorted to pack the flat sequence in deterministic order. This is true also for OrderedDict instances: their sequence order is ignored, the sorting order of keys is used instead. The same convention is followed in flatten. This correctly repacks dicts and OrderedDicts after they have been flattened, and also allows flattening an OrderedDict and then repacking it back using a corresponding plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be flattened.")]),e._v(" "),s("h4",{attrs:{id:"args"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("structure")]),e._v(": Nested "),s("code",[e._v("structure")]),e._v(", whose "),s("code",[e._v("structure")]),e._v(" is given by nested lists, tuples, and dicts. Note: numpy arrays and strings are considered scalars.")]),e._v(" "),s("li",[s("code",[e._v("flat_sequence")]),e._v(": flat sequence to pack.")]),e._v(" "),s("li",[s("code",[e._v("expand_composites")]),e._v(": If true, then composite tensors such as "),s("code",[e._v("tf.SparseTensor")]),e._v(" and "),s("code",[e._v("tf.RaggedTensor")]),e._v(" are expanded into their component tensors.")])]),e._v(" "),s("h4",{attrs:{id:"returns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("packed")]),e._v(": "),s("code",[e._v("flat_sequence")]),e._v(" converted to have the same recursive "),s("code",[e._v("structure")]),e._v(" as "),s("code",[e._v("structure")]),e._v(".")])]),e._v(" "),s("h4",{attrs:{id:"raises"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("ValueError")]),e._v(": If "),s("code",[e._v("flat_sequence")]),e._v(" and "),s("code",[e._v("structure")]),e._v(" have different element counts.")]),e._v(" "),s("li",[s("code",[e._v("TypeError")]),e._v(": "),s("code",[e._v("structure")]),e._v(" is or contains a dict with non-sortable keys.")])])])}),[],!1,null,null,null);t.default=r.exports}}]);