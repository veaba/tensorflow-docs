(window.webpackJsonp=window.webpackJsonp||[]).push([[1374],{1565:function(e,a,t){"use strict";t.r(a);var i=t(0),v=Object(i.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Computes SSIM index between img1 and img2.")]),e._v(" "),t("h3",{attrs:{id:"aliases"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("tf.compat.v1.image.ssim")])]),e._v(" "),t("li",[t("code",[e._v("tf.compat.v2.image.ssim")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" tf.image.ssim(\n    img1,\n    img2,\n    max_val,\n    filter_size=11,\n    filter_sigma=1.5,\n    k1=0.01,\n    k2=0.03\n)\n")])])]),t("p",[e._v("This function is based on the standard SSIM implementation from: Wang, Z., Bovik, A. C., Sheikh, H. R., & Simoncelli, E. P. (2004). Image quality assessment: from error visibility to structural similarity. IEEE transactions on image processing.")]),e._v(" "),t("h4",{attrs:{id:"details"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#details","aria-hidden":"true"}},[e._v("#")]),e._v(" Details:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("1")]),e._v("1"),t("code",[e._v("x")]),e._v("1"),t("code",[e._v("1")]),e._v(" "),t("code",[e._v("G")]),e._v("a"),t("code",[e._v("u")]),e._v("s"),t("code",[e._v("s")]),e._v("i"),t("code",[e._v("a")]),e._v("n"),t("code"),e._v("f"),t("code",[e._v("i")]),e._v("l"),t("code",[e._v("t")]),e._v("e"),t("code",[e._v("r")]),e._v(" "),t("code",[e._v("o")]),e._v("f"),t("code"),e._v("w"),t("code",[e._v("i")]),e._v("d"),t("code",[e._v("t")]),e._v("h"),t("code"),e._v("1"),t("code",[e._v(".")]),e._v("5"),t("code"),e._v("i"),t("code",[e._v("s")]),e._v(" "),t("code",[e._v("u")]),e._v("s"),t("code",[e._v("e")]),e._v("d"),t("code",[e._v(".")])]),e._v(" "),t("li",[t("code",[e._v("k")]),e._v("1"),t("code"),e._v("="),t("code"),e._v("0"),t("code",[e._v(".")]),e._v("0"),t("code",[e._v("1")]),e._v(","),t("code"),e._v("k"),t("code",[e._v("2")]),e._v(" "),t("code",[e._v("=")]),e._v(" "),t("code",[e._v("0")]),e._v("."),t("code",[e._v("0")]),e._v("3"),t("code"),e._v("a"),t("code",[e._v("s")]),e._v(" "),t("code",[e._v("i")]),e._v("n"),t("code"),e._v("t"),t("code",[e._v("h")]),e._v("e"),t("code"),e._v("o"),t("code",[e._v("r")]),e._v("i"),t("code",[e._v("g")]),e._v("i"),t("code",[e._v("n")]),e._v("a"),t("code",[e._v("l")]),e._v(" "),t("code",[e._v("p")]),e._v("a"),t("code",[e._v("p")]),e._v("e"),t("code",[e._v("r")]),e._v(".``")])]),e._v(" "),t("p",[e._v("The image sizes must be at least 11x11 because of the filter size.")]),e._v(" "),t("h4",{attrs:{id:"example"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#example","aria-hidden":"true"}},[e._v("#")]),e._v(" Example:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("     # Read images from file.\n    im1 = tf.decode_png('path/to/im1.png')\n    im2 = tf.decode_png('path/to/im2.png')\n    # Compute SSIM over tf.uint8 Tensors.\n    ssim1 = tf.image.ssim(im1, im2, max_val=255, filter_size=11,\n                          filter_sigma=1.5, k1=0.01, k2=0.03)\n\n    # Compute SSIM over tf.float32 Tensors.\n    im1 = tf.image.convert_image_dtype(im1, tf.float32)\n    im2 = tf.image.convert_image_dtype(im2, tf.float32)\n    ssim2 = tf.image.ssim(im1, im2, max_val=1.0, filter_size=11,\n                          filter_sigma=1.5, k1=0.01, k2=0.03)\n    # ssim1 and ssim2 both have type tf.float32 and are almost equal.\n")])])]),t("h4",{attrs:{id:"args"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("img1")]),e._v(": First image batch.")]),e._v(" "),t("li",[t("code",[e._v("img2")]),e._v(": Second image batch.")]),e._v(" "),t("li",[t("code",[e._v("max_val")]),e._v(": The dynamic range of the images (i.e., the difference between the maximum the and minimum allowed values).")]),e._v(" "),t("li",[t("code",[e._v("filter_size")]),e._v(": Default value 11 (size of gaussian filter).")]),e._v(" "),t("li",[t("code",[e._v("filter_sigma")]),e._v(": Default value 1.5 (width of gaussian filter).")]),e._v(" "),t("li",[t("code",[e._v("k1")]),e._v(": Default value 0.01")]),e._v(" "),t("li",[t("code",[e._v("k2")]),e._v(": Default value 0.03 (SSIM is less sensitivity to K2 for lower values, so it would be better if we taken the values in range of 0< K2 <0.4).")])]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),t("p",[e._v("A tensor containing an SSIM value for each image in batch. Returned SSIM values are in range (-1, 1], when pixel values are non-negative. Returns a tensor with shape: broadcast(img1.shape[:-3], img2.shape[:-3]).")])])}),[],!1,null,null,null);a.default=v.exports}}]);