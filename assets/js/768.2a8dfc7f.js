(window.webpackJsonp=window.webpackJsonp||[]).push([[768],{956:function(e,t,s){"use strict";s.r(t);var a=s(0),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("Applies sparse updates to individual values or slices in a Variable.")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" tf.compat.v1.scatter_nd_update(\n    ref,\n    indices,\n    updates,\n    use_locking=True,\n    name=None\n)\n")])])]),s("p",[e._v("ref is a Tensor with rank P and indices is a Tensor of rank Q.")]),e._v(" "),s("p",[e._v("indices must be integer tensor, containing indices into ref. It must be shape [d_0, ..., d_{Q-2}, K] where 0 < K <= P.")]),e._v(" "),s("p",[e._v("The innermost dimension of indices (with length K) corresponds to indices into elements (if K = P) or slices (if K < P) along the Kth dimension of ref.")]),e._v(" "),s("p",[e._v("updates is Tensor of rank Q-1+P-K with shape:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].\n")])])]),s("p",[e._v("For example, say we want to update 4 scattered elements to a rank-1 tensor to 8 elements. In Python, that update would look like this:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("     ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n    indices = tf.constant([[4], [3], [1] ,[7]])\n    updates = tf.constant([9, 10, 11, 12])\n    update = tf.compat.v1.scatter_nd_update(ref, indices, updates)\n    with tf.compat.v1.Session() as sess:\n      print sess.run(update)\n")])])]),s("p",[e._v("The resulting update to ref would look like this:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" [1, 11, 3, 10, 9, 6, 7, 12]\n")])])]),s("p",[s("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/scatter_nd",target:"_blank",rel:"noopener noreferrer"}},[e._v("tf.scatter_nd"),s("OutboundLink")],1),e._v("See  for more details about how to make updates to slices.")]),e._v(" "),s("h4",{attrs:{id:"args"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("ref")]),e._v(": A Variable.")]),e._v(" "),s("li",[s("code",[e._v("indices")]),e._v(": A "),s("code",[e._v("Tensor")]),e._v(". Must be one of the following types: "),s("code",[e._v("int32")]),e._v(", "),s("code",[e._v("int64")]),e._v(". A tensor of "),s("code",[e._v("indices")]),e._v(" into "),s("code",[e._v("ref")]),e._v(".")]),e._v(" "),s("li",[s("code",[e._v("updates")]),e._v(": A "),s("code",[e._v("Tensor")]),e._v(". Must have the same type as "),s("code",[e._v("ref")]),e._v(". A "),s("code",[e._v("Tensor")]),e._v(". Must have the same type as "),s("code",[e._v("ref")]),e._v(". A tensor of updated values to add to "),s("code",[e._v("ref")]),e._v(".")]),e._v(" "),s("li",[s("code",[e._v("use_locking")]),e._v(": An optional "),s("code",[e._v("bool")]),e._v(". Defaults to "),s("code",[e._v("True")]),e._v(". An optional "),s("code",[e._v("bool")]),e._v(". Defaults to "),s("code",[e._v("True")]),e._v(". If "),s("code",[e._v("True")]),e._v(", the assignment will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.")]),e._v(" "),s("li",[s("code",[e._v("name")]),e._v(": A "),s("code",[e._v("name")]),e._v(" for the operation (optional).")])]),e._v(" "),s("h4",{attrs:{id:"returns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),s("p",[e._v("The value of the variable after the update.")])])}),[],!1,null,null,null);t.default=n.exports}}]);