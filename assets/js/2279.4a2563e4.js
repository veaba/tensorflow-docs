(window.webpackJsonp=window.webpackJsonp||[]).push([[2279],{2467:function(t,a,e){"use strict";e.r(a);var s=e(0),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("Stacks dynamic partitions of a Tensor or RaggedTensor.")]),t._v(" "),e("h3",{attrs:{id:"aliases"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[t._v("#")]),t._v(" Aliases:")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("tf.compat.v1.ragged.stack_dynamic_partitions")])]),t._v(" "),e("li",[e("code",[t._v("tf.compat.v2.ragged.stack_dynamic_partitions")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" tf.ragged.stack_dynamic_partitions(\n    data,\n    partitions,\n    num_partitions,\n    name=None\n)\n")])])]),e("p",[t._v("Returns a RaggedTensor output with num_partitions rows, where the row output[i] is formed by stacking all slices data[j1...jN] such that partitions[j1...jN] = i. Slices of data are stacked in row-major order.")]),t._v(" "),e("p",[t._v("If num_partitions is an int (not a Tensor), then this is equivalent to tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions)).")]),t._v(" "),e("h4",{attrs:{id:"example"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#example","aria-hidden":"true"}},[t._v("#")]),t._v(" Example:")]),t._v(" "),e("h4",{attrs:{id:"args"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[t._v("#")]),t._v(" Args:")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("data")]),t._v(": A "),e("code",[t._v("Tensor")]),t._v(" or "),e("code",[t._v("RaggedTensor")]),t._v(" containing the values to stack.")]),t._v(" "),e("li",[e("code",[t._v("partitions")]),t._v(": An "),e("code",[t._v("int32")]),t._v(" or "),e("code",[t._v("int64")]),t._v(" "),e("code",[t._v("Tensor")]),t._v(" or "),e("code",[t._v("RaggedTensor")]),t._v(" specifying the partition that each slice of "),e("code",[t._v("data")]),t._v(" should be added to. "),e("code",[t._v("partitions")]),t._v(".shape must be a prefix of "),e("code",[t._v("data")]),t._v(".shape. Values must be greater than or equal to zero, and less than "),e("code",[t._v("num_partitions")]),t._v(". "),e("code",[t._v("partitions")]),t._v(" is not required to be sorted.")]),t._v(" "),e("li",[e("code",[t._v("num_partitions")]),t._v(": An "),e("code",[t._v("int32")]),t._v(" or "),e("code",[t._v("int64")]),t._v(" scalar specifying the number of "),e("code",[t._v("partitions")]),t._v(" to "),e("code",[t._v("output")]),t._v(". This determines the number of rows in "),e("code",[t._v("output")]),t._v(".")]),t._v(" "),e("li",[e("code",[t._v("name")]),t._v(": A "),e("code",[t._v("name")]),t._v(" prefix for the returned tensor (optional).")])]),t._v(" "),e("h4",{attrs:{id:"returns"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[t._v("#")]),t._v(" Returns:")]),t._v(" "),e("p",[t._v("A RaggedTensor containing the stacked partitions. The returned tensor has the same dtype as data, and its shape is [num_partitions, (D)] + data.shape[partitions.rank:], where (D) is a ragged dimension whose length is the number of data slices stacked for each partition.")])])}),[],!1,null,null,null);a.default=r.exports}}]);