(window.webpackJsonp=window.webpackJsonp||[]).push([[632],{820:function(e,s,t){"use strict";t.r(s);var a=t(0),r=Object(a.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Computes the CTC (Connectionist Temporal Classification) Loss.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" tf.compat.v1.nn.ctc_loss(\n    labels,\n    inputs=None,\n    sequence_length=None,\n    preprocess_collapse_repeated=False,\n    ctc_merge_repeated=True,\n    ignore_longer_outputs_than_inputs=False,\n    time_major=True,\n    logits=None\n)\n")])])]),t("p",[e._v("This op implements the CTC loss as presented in the article:\n"),t("a",{attrs:{href:"http://www.cs.toronto.edu/~graves/icml_2006.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("A. Graves, S. Fernandez, F. Gomez, J. Schmidhuber. Connectionist Temporal Classification: Labeling Unsegmented Sequence Data with Recurrent Neural Networks. ICML 2006, Pittsburgh, USA, pp. 369-376."),t("OutboundLink")],1)]),e._v(" "),t("h4",{attrs:{id:"input-requirements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#input-requirements","aria-hidden":"true"}},[e._v("#")]),e._v(" Input requirements:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" sequence_length(b) <= time for all b\n\nmax(labels.indices(labels.indices[:, 1] == b, 2))\n  <= sequence_length(b) for all b.\n")])])]),t("h4",{attrs:{id:"notes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#notes","aria-hidden":"true"}},[e._v("#")]),e._v(" Notes:")]),e._v(" "),t("p",[e._v("This class performs the softmax operation for you, so inputs should be e.g. linear projections of outputs by an LSTM.")]),e._v(" "),t("p",[e._v("The inputs Tensor's innermost dimension size, num_classes, represents num_labels + 1 classes, where num_labels is the number of true labels, and the largest value (num_classes - 1) is reserved for the blank label.")]),e._v(" "),t("p",[e._v("For example, for a vocabulary containing 3 labels [a, b, c], num_classes = 4 and the labels indexing is {a: 0, b: 1, c: 2, blank: 3}.")]),e._v(" "),t("p",[e._v("Regarding the arguments preprocess_collapse_repeated and ctc_merge_repeated:")]),e._v(" "),t("p",[e._v("If preprocess_collapse_repeated is True, then a preprocessing step runs before loss calculation, wherein repeated labels passed to the loss are merged into single labels. This is useful if the training labels come from, e.g., forced alignments and therefore have unnecessary repetitions.")]),e._v(" "),t("p",[e._v("If ctc_merge_repeated is set False, then deep within the CTC calculation, repeated non-blank labels will not be merged and are interpreted as individual labels. This is a simplified (non-standard) version of CTC.")]),e._v(" "),t("p",[e._v("Here is a table of the (roughly) expected first order behavior:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("preprocess_collapse_repeated=False")]),e._v(", "),t("code",[e._v("ctc_merge_repeated=True")]),e._v("\nClassical CTC behavior: Outputs true repeated classes with blanks in between, and can also output repeated classes with no blanks in between that need to be collapsed by the decoder.")]),e._v(" "),t("li",[t("code",[e._v("preprocess_collapse_repeated=True")]),e._v(", "),t("code",[e._v("ctc_merge_repeated=False")]),e._v("\nNever learns to output repeated classes, as they are collapsed in the input labels before training.")]),e._v(" "),t("li",[t("code",[e._v("preprocess_collapse_repeated=False")]),e._v(", "),t("code",[e._v("ctc_merge_repeated=False")]),e._v("\nOutputs repeated classes with blanks in between, but generally does not require the decoder to collapse/merge repeated classes.")]),e._v(" "),t("li",[t("code",[e._v("preprocess_collapse_repeated=True")]),e._v(", "),t("code",[e._v("ctc_merge_repeated=True")]),e._v("\nUntested. Very likely will not learn to output repeated classes.")])]),e._v(" "),t("p",[e._v("The ignore_longer_outputs_than_inputs option allows to specify the behavior of the CTCLoss when dealing with sequences that have longer outputs than inputs. If true, the CTCLoss will simply return zero gradient for those items, otherwise an InvalidArgument error is returned, stopping training.")]),e._v(" "),t("h4",{attrs:{id:"args"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),t("p",[e._v("A 1-D float Tensor, size [batch], containing the negative log probabilities.")]),e._v(" "),t("h4",{attrs:{id:"raises"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("TypeError")]),e._v(": if labels is not a "),t("code",[e._v("SparseTensor")]),e._v(".")])])])}),[],!1,null,null,null);s.default=r.exports}}]);