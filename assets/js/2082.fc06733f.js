(window.webpackJsonp=window.webpackJsonp||[]).push([[2082],{2270:function(e,t,a){"use strict";a.r(t);var s=a(0),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Compute the cumulative log-sum-exp of the tensor x along axis.")]),e._v(" "),a("h3",{attrs:{id:"aliases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("tf.compat.v1.math.cumulative_logsumexp")])]),e._v(" "),a("li",[a("code",[e._v("tf.compat.v2.math.cumulative_logsumexp")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" tf.math.cumulative_logsumexp(\n    x,\n    axis=0,\n    exclusive=False,\n    reverse=False,\n    name=None\n)\n")])])]),a("p",[e._v("By default, this op performs an inclusive cumulative log-sum-exp, which means that the first element of the input is identical to the first element of the output.\n"),a("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/math/reduce_logsumexp",target:"_blank",rel:"noopener noreferrer"}},[e._v("tf.math.reduce_logsumexp"),a("OutboundLink")],1),e._v('This operation is significantly more numerically stable than the equivalent tensorflow operation tf.math.log(tf.math.cumsum(tf.math.exp(x))), although computes the same result given infinite numerical precision. However, note that in some cases, it may be less stable than  for a given element, as it applies the "log-sum-exp trick" in a different way.')]),e._v(" "),a("p",[a("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/math/reduce_logsumexp",target:"_blank",rel:"noopener noreferrer"}},[e._v("tf.math.reduce_logsumexp"),a("OutboundLink")],1),e._v("More precisely, where  uses the following trick:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" log(sum(exp(x))) == log(sum(exp(x - max(x)))) + max(x)\n")])])]),a("p",[e._v("it cannot be directly used here as there is no fast way of applying it to each prefix x[:i]. Instead, this function implements a prefix scan using pairwise log-add-exp, which is a commutative and associative (up to floating point precision) operator:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" log_add_exp(x, y) = log(exp(x) + exp(y))\n                  = log(1 + exp(min(x, y) - max(x, y))) + max(x, y)\n")])])]),a("p",[e._v("However, reducing using the above operator leads to a different computation tree (logs are taken repeatedly instead of only at the end), and the maximum is only computed pairwise instead of over the entire prefix. In general, this leads to a different and slightly less precise computation.")]),e._v(" "),a("h4",{attrs:{id:"args"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("x")]),e._v(": A "),a("code",[e._v("Tensor")]),e._v(". Must be one of the following types: "),a("code",[e._v("float16")]),e._v(", "),a("code",[e._v("float32")]),e._v(", "),a("code",[e._v("float64")]),e._v(".")])]),e._v(" "),a("h4",{attrs:{id:"returns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),a("p",[e._v("A Tensor. Has the same shape and type as x.")])])}),[],!1,null,null,null);t.default=o.exports}}]);