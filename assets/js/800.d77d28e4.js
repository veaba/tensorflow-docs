(window.webpackJsonp=window.webpackJsonp||[]).push([[800],{988:function(t,e,r){"use strict";r.r(e);var a=r(0),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("Converts each string in the input Tensor to the specified numeric type.")]),t._v(" "),r("h3",{attrs:{id:"aliases"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[t._v("#")]),t._v(" Aliases:")]),t._v(" "),r("ul",[r("li",[r("code",[t._v("tf.compat.v1.strings.to_number")])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v(" tf.compat.v1.string_to_number(\n    string_tensor=None,\n    out_type=tf.dtypes.float32,\n    name=None,\n    input=None\n)\n")])])]),r("p",[t._v("(Note that int32 overflow results in an error while float overflow results in a rounded value.)")]),t._v(" "),r("h4",{attrs:{id:"args"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[t._v("#")]),t._v(" Args:")]),t._v(" "),r("ul",[r("li",[r("code",[t._v("string_tensor")]),t._v(": A "),r("code",[t._v("Tensor")]),t._v(" of type "),r("code",[t._v("string")]),t._v(".")]),t._v(" "),r("li",[r("code",[t._v("out_type")]),t._v(": An optional "),r("code",[t._v("tf.DType")]),t._v(" from: "),r("code",[t._v("tf.float32, tf.float64, tf.int32, tf.int64")]),t._v(". Defaults to "),r("code",[t._v("tf.float32")]),t._v(". The numeric type to interpret each "),r("code",[t._v("string")]),t._v(" in "),r("code",[t._v("string_tensor")]),t._v(" as.")]),t._v(" "),r("li",[r("code",[t._v("name")]),t._v(": A "),r("code",[t._v("name")]),t._v(" for the operation (optional).")])]),t._v(" "),r("h4",{attrs:{id:"returns"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[t._v("#")]),t._v(" Returns:")]),t._v(" "),r("p",[t._v("A Tensor of type out_type.")])])}),[],!1,null,null,null);e.default=n.exports}}]);