(window.webpackJsonp=window.webpackJsonp||[]).push([[2055],{2243:function(e,t,a){"use strict";a.r(t);var s=a(0),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Returns the element-wise sum of a list of tensors.")]),e._v(" "),a("h3",{attrs:{id:"aliases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("tf.compat.v1.accumulate_n")])]),e._v(" "),a("li",[a("code",[e._v("tf.compat.v1.math.accumulate_n")])]),e._v(" "),a("li",[a("code",[e._v("tf.compat.v2.math.accumulate_n")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" tf.math.accumulate_n(\n    inputs,\n    shape=None,\n    tensor_dtype=None,\n    name=None\n)\n")])])]),a("p",[e._v("Optionally, pass shape and tensor_dtype for shape and type checking, otherwise, these are inferred.\n"),a("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/math/add_n",target:"_blank",rel:"noopener noreferrer"}},[e._v("tf.math.add_n"),a("OutboundLink")],1),e._v("accumulate_n performs the same operation as , but does not wait for all of its inputs to be ready before beginning to sum. This approach can save memory if inputs are ready at different times, since minimum temporary storage is proportional to the output size rather than the inputs' size.")]),e._v(" "),a("p",[e._v("accumulate_n is differentiable (but wasn't previous to TensorFlow 1.7).")]),e._v(" "),a("h4",{attrs:{id:"for-example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for-example","aria-hidden":"true"}},[e._v("#")]),e._v(" For example:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" a = tf.constant([[1, 2], [3, 4]])\nb = tf.constant([[5, 0], [0, 6]])\ntf.math.accumulate_n([a, b, a])  # [[7, 4], [6, 14]]\n\n# Explicitly pass shape and type\ntf.math.accumulate_n([a, b, a], shape=[2, 2], tensor_dtype=tf.int32)\n                                                               # [[7,  4],\n                                                               #  [6, 14]]\n")])])]),a("h4",{attrs:{id:"args"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("inputs")]),e._v(": A list of "),a("code",[e._v("Tensor")]),e._v(" objects, each with same shape and type.")]),e._v(" "),a("li",[a("code",[e._v("shape")]),e._v(": Expected "),a("code",[e._v("shape")]),e._v(" of elements of "),a("code",[e._v("inputs")]),e._v(" (optional). Also controls the output "),a("code",[e._v("shape")]),e._v(" of this op, which may affect type inference in other ops. A value of "),a("code",[e._v("None")]),e._v(' means "infer the input '),a("code",[e._v("shape")]),e._v(" from the "),a("code",[e._v("shape")]),e._v("s in "),a("code",[e._v("inputs")]),e._v('".')]),e._v(" "),a("li",[a("code",[e._v("tensor_dtype")]),e._v(": Expected data type of "),a("code",[e._v("inputs")]),e._v(" (optional). A value of "),a("code",[e._v("None")]),e._v(' means "infer the input dtype from '),a("code",[e._v("inputs")]),e._v('[0]".')]),e._v(" "),a("li",[a("code",[e._v("name")]),e._v(": A "),a("code",[e._v("name")]),e._v(" for the operation (optional).")])]),e._v(" "),a("h4",{attrs:{id:"returns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),a("p",[e._v("A Tensor of same shape and type as the elements of inputs.")]),e._v(" "),a("h4",{attrs:{id:"raises"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("ValueError")]),e._v(": If "),a("code",[e._v("inputs")]),e._v(" don't all have same shape and dtype or the shape cannot be inferred.")])])])}),[],!1,null,null,null);t.default=n.exports}}]);