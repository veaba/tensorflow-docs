(window.webpackJsonp=window.webpackJsonp||[]).push([[1400],{1591:function(e,s,a){"use strict";a.r(s);var r=a(0),t=Object(r.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Deserialize and concatenate SparseTensors from a serialized minibatch.")]),e._v(" "),a("h3",{attrs:{id:"aliases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("tf.compat.v1.deserialize_many_sparse")])]),e._v(" "),a("li",[a("code",[e._v("tf.compat.v1.io.deserialize_many_sparse")])]),e._v(" "),a("li",[a("code",[e._v("tf.compat.v2.io.deserialize_many_sparse")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" tf.io.deserialize_many_sparse(\n    serialized_sparse,\n    dtype,\n    rank=None,\n    name=None\n)\n")])])]),a("p",[e._v("The input serialized_sparse must be a string matrix of shape [N x 3] where N is the minibatch size and the rows correspond to packed outputs of serialize_sparse. The ranks of the original SparseTensor objects must all match. When the final SparseTensor is created, it has rank one higher than the ranks of the incoming SparseTensor objects (they have been concatenated along a new row dimension).")]),e._v(" "),a("p",[e._v("The output SparseTensor object's shape values for all dimensions but the first are the max across the input SparseTensor objects' shape values for the corresponding dimensions. Its first shape value is N, the minibatch size.\n"),a("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/sparse/reorder",target:"_blank",rel:"noopener noreferrer"}},[e._v("sparse.reorder"),a("OutboundLink")],1),e._v("The input SparseTensor objects' indices are assumed ordered in standard lexicographic order. If this is not the case, after this step run  to restore index ordering.")]),e._v(" "),a("p",[e._v("For example, if the serialized input is a [2, 3] matrix representing two original SparseTensor objects:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" index = [ 0]\n        [10]\n        [20]\nvalues = [1, 2, 3]\nshape = [50]\n")])])]),a("p",[e._v("and")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" index = [ 2]\n        [10]\nvalues = [4, 5]\nshape = [30]\n")])])]),a("p",[e._v("then the final deserialized SparseTensor will be:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" index = [0  0]\n        [0 10]\n        [0 20]\n        [1  2]\n        [1 10]\nvalues = [1, 2, 3, 4, 5]\nshape = [2 50]\n")])])]),a("h4",{attrs:{id:"args"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("serialized_sparse")]),e._v(":"),a("code"),e._v("2-D"),a("code",[e._v("``Tensor``")]),e._v("of"),a("code"),e._v("type"),a("code",[e._v("``string``")]),e._v("of"),a("code"),e._v("shape"),a("code"),e._v("["),a("code",[e._v("N``,`` ``3")]),e._v("]."),a("code"),e._v("The"),a("code"),e._v("serialized"),a("code"),e._v("and"),a("code"),e._v("packed"),a("code",[e._v("``SparseTensor``")]),e._v("objects.")]),e._v(" "),a("li",[a("code",[e._v("dtype")]),e._v(":"),a("code"),e._v("The"),a("code",[e._v("``dtype``")]),e._v("of"),a("code"),e._v("the"),a("code"),e._v("serialized"),a("code",[e._v("``SparseTensor``")]),e._v("objects.")]),e._v(" "),a("li",[a("code",[e._v("rank")]),e._v(":"),a("code"),e._v("(optional)"),a("code"),e._v("Python"),a("code"),e._v("int"),a("code",[e._v(",``")]),e._v("the"),a("code",[e._v("``rank``")]),e._v("of"),a("code"),e._v("the"),a("code",[e._v("``SparseTensor``")]),e._v("objects.")]),e._v(" "),a("li",[a("code",[e._v("name")]),e._v(":"),a("code"),e._v("A"),a("code",[e._v("``name``")]),e._v("prefix"),a("code"),e._v("for"),a("code"),e._v("the"),a("code"),e._v("returned"),a("code"),e._v("tensors"),a("code"),e._v("(optional)")])]),e._v(" "),a("h4",{attrs:{id:"returns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),a("p",[e._v("A SparseTensor representing the deserialized SparseTensors, concatenated along the SparseTensors' first dimension.")]),e._v(" "),a("p",[e._v("All of the serialized SparseTensors must have had the same rank and type.")])])}),[],!1,null,null,null);s.default=t.exports}}]);