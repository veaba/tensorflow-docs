(window.webpackJsonp=window.webpackJsonp||[]).push([[2350],{2538:function(e,a,s){"use strict";s.r(a);var r=s(0),t=Object(r.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("Reorders a SparseTensor into the canonical, row-major ordering.")]),e._v(" "),s("h3",{attrs:{id:"aliases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("tf.compat.v1.sparse.reorder")])]),e._v(" "),s("li",[s("code",[e._v("tf.compat.v1.sparse_reorder")])]),e._v(" "),s("li",[s("code",[e._v("tf.compat.v2.sparse.reorder")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" tf.sparse.reorder(\n    sp_input,\n    name=None\n)\n")])])]),s("p",[e._v("Note that by convention, all sparse ops preserve the canonical ordering along increasing dimension number. The only time ordering can be violated is during manual manipulation of the indices and values to add entries.")]),e._v(" "),s("p",[e._v("Reordering does not affect the shape of the SparseTensor.")]),e._v(" "),s("p",[e._v("For example, if sp_input has shape [4, 5] and indices / values:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" [0, 3]: b\n[0, 1]: a\n[3, 1]: d\n[2, 0]: c\n")])])]),s("p",[e._v("then the output will be a SparseTensor of shape [4, 5] and indices / values:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" [0, 1]: a\n[0, 3]: b\n[2, 0]: c\n[3, 1]: d\n")])])]),s("h4",{attrs:{id:"args"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("sp_input")]),e._v(": The input "),s("code",[e._v("SparseTensor")]),e._v(".")]),e._v(" "),s("li",[s("code",[e._v("name")]),e._v(": A "),s("code",[e._v("name")]),e._v(" prefix for the returned tensors (optional)")])]),e._v(" "),s("h4",{attrs:{id:"returns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),s("p",[e._v("A SparseTensor with the same shape and non-empty values, but in canonical ordering.")]),e._v(" "),s("h4",{attrs:{id:"raises"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("TypeError")]),e._v(": If "),s("code",[e._v("sp_input")]),e._v(" is not a "),s("code",[e._v("SparseTensor")]),e._v(".")])])])}),[],!1,null,null,null);a.default=t.exports}}]);