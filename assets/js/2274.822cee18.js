(window.webpackJsonp=window.webpackJsonp||[]).push([[2274],{2462:function(e,a,t){"use strict";t.r(a);var s=t(0),r=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Applies op to the values of one or more RaggedTensors.")]),e._v(" "),t("h3",{attrs:{id:"aliases"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("tf.compat.v1.ragged.map_flat_values")])]),e._v(" "),t("li",[t("code",[e._v("tf.compat.v2.ragged.map_flat_values")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" tf.ragged.map_flat_values(\n    op,\n    *args,\n    **kwargs\n)\n")])])]),t("h3",{attrs:{id:"used-in-the-guide"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#used-in-the-guide","aria-hidden":"true"}},[e._v("#")]),e._v(" Used in the guide:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("R")]),e._v("a"),t("code",[e._v("g")]),e._v("g"),t("code",[e._v("e")]),e._v("d"),t("code"),e._v("t"),t("code",[e._v("e")]),e._v("n"),t("code",[e._v("s")]),e._v("o"),t("code",[e._v("r")]),e._v("s``")])]),e._v(" "),t("p",[e._v("Replaces any RaggedTensor in args or kwargs with its flat_values tensor, and then calls op. Returns a RaggedTensor that is constructed from the input RaggedTensors' nested_row_splits and the value returned by the op.")]),e._v(" "),t("p",[e._v("If the input arguments contain multiple RaggedTensors, then they must have identical nested_row_splits.")]),e._v(" "),t("h4",{attrs:{id:"examples"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#examples","aria-hidden":"true"}},[e._v("#")]),e._v(" Examples:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" rt = ragged.constant([[1, 2, 3], [], [4, 5], [6]])\nragged.map_flat_values(tf.ones_like, rt).eval().tolist()\n[[1, 1, 1], [], [1, 1], [1]]\nragged.map_flat_values(tf.multiply, rt, rt).eval().tolist()\n[[1, 4, 9], [], [16, 25], [36]]\nragged.map_flat_values(tf.add, rt, 5).eval().tolist()\n[[6, 7, 8], [], [9, 10], [11]]\n")])])]),t("h4",{attrs:{id:"args"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("op")]),e._v(": The "),t("code",[e._v("op")]),e._v("eration that should be applied to the "),t("code",[e._v("RaggedTensor")]),e._v(" "),t("code",[e._v("flat_values")]),e._v(". "),t("code",[e._v("op")]),e._v(" is typically an element-wise "),t("code",[e._v("op")]),e._v("eration (such as math_"),t("code",[e._v("op")]),e._v("s.add), but any "),t("code",[e._v("op")]),e._v("eration that preserves the size of the outermost dimension can be used. I.e., shape[0] of the value returned by "),t("code",[e._v("op")]),e._v(" must match shape[0] of the "),t("code",[e._v("RaggedTensor")]),e._v("s' "),t("code",[e._v("flat_values")]),e._v(" tensors.")])]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),t("p",[e._v("A RaggedTensor whose ragged_rank matches the ragged_rank of all input RaggedTensors.")]),e._v(" "),t("h4",{attrs:{id:"raises"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("ValueError")]),e._v(": If args contains no "),t("code",[e._v("RaggedTensors")]),e._v(", or if the "),t("code",[e._v("nested_splits")]),e._v(" of the input "),t("code",[e._v("RaggedTensors")]),e._v(" are not identical.")])])])}),[],!1,null,null,null);a.default=r.exports}}]);