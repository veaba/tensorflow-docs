(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{215:function(t,e,n){"use strict";n.r(e);var s=n(0),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("Defined in generated file: python/ops/gen_bitwise_ops.py")]),t._v(" "),n("p",[t._v("Invert (flip) each bit of supported types; for example, type uint8 value 01010101 becomes 10101010.")]),t._v(" "),n("h3",{attrs:{id:"aliases"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[t._v("#")]),t._v(" Aliases:")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("tf.compat.v1.bitwise.invert")])]),t._v(" "),n("li",[n("code",[t._v("tf.compat.v2.bitwise.invert")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" tf.bitwise.invert(\n    x,\n    name=None\n)\n")])])]),n("p",[t._v("Flip each bit of supported types. For example, type int8 (decimal 2) binary 00000010 becomes (decimal -3) binary 11111101. This operation is performed on each element of the tensor argument x.")]),t._v(" "),n("h4",{attrs:{id:"example"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example","aria-hidden":"true"}},[t._v("#")]),t._v(" Example:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" import tensorflow as tf\nfrom tensorflow.python.ops import bitwise_ops\n\n# flip 2 (00000010) to -3 (11111101)\ntf.assert_equal(-3, bitwise_ops.invert(2))\n\ndtype_list = [dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64,\n              dtypes.uint8, dtypes.uint16, dtypes.uint32, dtypes.uint64]\n\ninputs = [0, 5, 3, 14]\nfor dtype in dtype_list:\n  # Because of issues with negative numbers, let's test this indirectly.\n  # 1. invert(a) and a = 0\n  # 2. invert(a) or a = invert(0)\n  input_tensor = tf.constant([0, 5, 3, 14], dtype=dtype)\n  not_a_and_a, not_a_or_a, not_0 = [bitwise_ops.bitwise_and(\n                                      input_tensor, bitwise_ops.invert(input_tensor)),\n                                    bitwise_ops.bitwise_or(\n                                      input_tensor, bitwise_ops.invert(input_tensor)),\n                                    bitwise_ops.invert(\n                                      tf.constant(0, dtype=dtype))]\n\n  expected = tf.constant([0, 0, 0, 0], dtype=tf.float32)\n  tf.assert_equal(tf.cast(not_a_and_a, tf.float32), expected)\n\n  expected = tf.cast([not_0] * 4, tf.float32)\n  tf.assert_equal(tf.cast(not_a_or_a, tf.float32), expected)\n\n  # For unsigned dtypes let's also check the result directly.\n  if dtype.is_unsigned:\n    inverted = bitwise_ops.invert(input_tensor)\n    expected = tf.constant([dtype.max - x for x in inputs], dtype=tf.float32)\n    tf.assert_equal(tf.cast(inverted, tf.float32), tf.cast(expected, tf.float32))\n")])])]),n("h4",{attrs:{id:"args"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[t._v("#")]),t._v(" Args:")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("x")]),t._v(": A "),n("code",[t._v("Tensor")]),t._v(". Must be one of the following types: "),n("code",[t._v("int8")]),t._v(", "),n("code",[t._v("int16")]),t._v(", "),n("code",[t._v("int32")]),t._v(", "),n("code",[t._v("int64")]),t._v(", "),n("code",[t._v("uint8")]),t._v(", "),n("code",[t._v("uint16")]),t._v(", "),n("code",[t._v("uint32")]),t._v(", "),n("code",[t._v("uint64")]),t._v(".")]),t._v(" "),n("li",[n("code",[t._v("name")]),t._v(": A "),n("code",[t._v("name")]),t._v(" for the operation (optional).")])]),t._v(" "),n("h4",{attrs:{id:"returns"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[t._v("#")]),t._v(" Returns:")]),t._v(" "),n("p",[t._v("A Tensor. Has the same type as x.")])])}),[],!1,null,null,null);e.default=a.exports}}]);