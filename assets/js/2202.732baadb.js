(window.webpackJsonp=window.webpackJsonp||[]).push([[2202],{2390:function(e,t,o){"use strict";o.r(t);var a=o(0),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("The transpose of convolution.")]),e._v(" "),o("h3",{attrs:{id:"aliases"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("tf.compat.v1.nn.conv_transpose")])]),e._v(" "),o("li",[o("code",[e._v("tf.compat.v2.nn.conv_transpose")])])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v(" tf.nn.conv_transpose(\n    input,\n    filters,\n    output_shape,\n    strides,\n    padding='SAME',\n    data_format=None,\n    dilations=None,\n    name=None\n)\n")])])]),o("p",[o("a",{attrs:{href:"http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Deconvolutional Networks"),o("OutboundLink")],1),e._v('This operation is sometimes called "deconvolution" after , but is actually the transpose (gradient) of convolution rather than an actual deconvolution.')]),e._v(" "),o("h4",{attrs:{id:"args"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("input")]),e._v(": An N+2 dimensional "),o("code",[e._v("Tensor")]),e._v(" of shape [batch_size] + "),o("code",[e._v("input")]),e._v('_spatial_shape + [in_channels] if data_format does not start with "NC" (default), or [batch_size, in_channels] + '),o("code",[e._v("input")]),e._v('_spatial_shape if data_format starts with "NC". It must be one of the following types: '),o("code",[e._v("half")]),e._v(", "),o("code",[e._v("bfloat16")]),e._v(", "),o("code",[e._v("float32")]),e._v(", "),o("code",[e._v("float64")]),e._v(".")]),e._v(" "),o("li",[o("code",[e._v("filters")]),e._v(": An N+2 dimensional "),o("code",[e._v("Tensor")]),e._v(" with the same type as "),o("code",[e._v("input")]),e._v(" and shape spatial_filter_shape + [in_channels, out_channels].")]),e._v(" "),o("li",[o("code",[e._v("output_shape")]),e._v(": A 1-D "),o("code",[e._v("Tensor")]),e._v(" representing the output shape of the deconvolution op.")]),e._v(" "),o("li",[o("code",[e._v("strides")]),e._v(": An int or list of "),o("code",[e._v("ints")]),e._v(" that has length "),o("code",[e._v("1")]),e._v(", "),o("code",[e._v("N")]),e._v(" or "),o("code",[e._v("N")]),e._v("+2. The stride of the sliding window for each dimension of "),o("code",[e._v("input")]),e._v(". If a single value is given it is replicated in the spatial dimensions. By default the "),o("code",[e._v("N")]),e._v(" and "),o("code",[e._v("C")]),e._v(" dimensions are set to 0. The dimension order is determined by the value of "),o("code",[e._v("data_format")]),e._v(", see below for details.")]),e._v(" "),o("li",[o("code",[e._v("padding")]),e._v(": A string, either "),o("code",[e._v("'VALID'")]),e._v(" or "),o("code",[e._v("'SAME'")]),e._v(". The "),o("code",[e._v("padding")]),e._v(' algorithm. See the "returns" section of '),o("code",[e._v("tf.nn.convolution")]),e._v(" for details.")]),e._v(" "),o("li",[o("code",[e._v("data_format")]),e._v(": A string or "),o("code",[e._v("N")]),e._v("one. Specifies whether the channel dimension of the "),o("code",[e._v("input")]),e._v(" and output is the last dimension (default, or if "),o("code",[e._v("data_format")]),e._v(' does not start with "'),o("code",[e._v("N``C")]),e._v('"), or the second dimension (if '),o("code",[e._v("data_format")]),e._v(' starts with "'),o("code",[e._v("N``C")]),e._v('"). For '),o("code",[e._v("N")]),e._v("="),o("code",[e._v("1")]),e._v(', the valid values are "'),o("code",[e._v("N")]),e._v("W"),o("code",[e._v("C")]),e._v('" (default) and "'),o("code",[e._v("N``C")]),e._v('W". For '),o("code",[e._v("N")]),e._v('=2, the valid values are "'),o("code",[e._v("N")]),e._v("HW"),o("code",[e._v("C")]),e._v('" (default) and "'),o("code",[e._v("N``C")]),e._v('HW". For '),o("code",[e._v("N")]),e._v('=3, the valid values are "'),o("code",[e._v("N")]),e._v("DHW"),o("code",[e._v("C")]),e._v('" (default) and "'),o("code",[e._v("N``C")]),e._v('DHW".')]),e._v(" "),o("li",[o("code",[e._v("dilations")]),e._v(": An int or list of "),o("code",[e._v("ints")]),e._v(" that has length "),o("code",[e._v("1")]),e._v(", "),o("code",[e._v("N")]),e._v(" or "),o("code",[e._v("N")]),e._v("+2, defaults to "),o("code",[e._v("1")]),e._v(". The dilation factor for each dimension of"),o("code",[e._v("input")]),e._v(". If a single value is given it is replicated in the spatial dimensions. By default the "),o("code",[e._v("N")]),e._v(" and "),o("code",[e._v("C")]),e._v(" dimensions are set to "),o("code",[e._v("1")]),e._v(". If set to k > "),o("code",[e._v("1")]),e._v(", there will be k-"),o("code",[e._v("1")]),e._v(" skipped cells between each filter element on that dimension. The dimension order is determined by the value of "),o("code",[e._v("data_format")]),e._v(", see above for details.")]),e._v(" "),o("li",[o("code",[e._v("name")]),e._v(": A "),o("code",[e._v("name")]),e._v(' for the operation (optional). If not specified "conv_transpose" is used.')])]),e._v(" "),o("h4",{attrs:{id:"returns"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),o("p",[e._v("A Tensor with the same type as value.")])])}),[],!1,null,null,null);t.default=n.exports}}]);