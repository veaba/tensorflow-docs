(window.webpackJsonp=window.webpackJsonp||[]).push([[2352],{2540:function(e,s,a){"use strict";a.r(s);var t=a(0),n=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Reshapes a SparseTensor to represent values in a new dense shape.")]),e._v(" "),a("h3",{attrs:{id:"aliases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("tf.compat.v1.sparse.reshape")])]),e._v(" "),a("li",[a("code",[e._v("tf.compat.v1.sparse_reshape")])]),e._v(" "),a("li",[a("code",[e._v("tf.compat.v2.sparse.reshape")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" tf.sparse.reshape(\n    sp_input,\n    shape,\n    name=None\n)\n")])])]),a("p",[e._v("This operation has the same semantics as reshape on the represented dense tensor. The indices of non-empty values in sp_input are recomputed based on the new dense shape, and a new SparseTensor is returned containing the new indices and new shape. The order of non-empty values in sp_input is unchanged.")]),e._v(" "),a("p",[e._v("If one component of shape is the special value -1, the size of that dimension is computed so that the total dense size remains constant. At most one component of shape can be -1. The number of dense elements implied by shape must be the same as the number of dense elements originally represented by sp_input.")]),e._v(" "),a("p",[e._v("For example, if sp_input has shape [2, 3, 6] and indices / values:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" [0, 0, 0]: a\n[0, 0, 1]: b\n[0, 1, 0]: c\n[1, 0, 0]: d\n[1, 2, 3]: e\n")])])]),a("p",[e._v("and shape is [9, -1], then the output will be a SparseTensor of shape [9, 4] and indices / values:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" [0, 0]: a\n[0, 1]: b\n[1, 2]: c\n[4, 2]: d\n[8, 1]: e\n")])])]),a("h4",{attrs:{id:"args"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("sp_input")]),e._v(": The input "),a("code",[e._v("SparseTensor")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("shape")]),e._v(": A 1-D (vector) int64 "),a("code",[e._v("Tensor")]),e._v(" specifying the new dense "),a("code",[e._v("shape")]),e._v(" of the represented "),a("code",[e._v("SparseTensor")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("name")]),e._v(": A "),a("code",[e._v("name")]),e._v(" prefix for the returned tensors (optional)")])]),e._v(" "),a("h4",{attrs:{id:"returns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),a("p",[e._v("A SparseTensor with the same non-empty values but with indices calculated by the new dense shape.")]),e._v(" "),a("h4",{attrs:{id:"raises"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("TypeError")]),e._v(": If "),a("code",[e._v("sp_input")]),e._v(" is not a "),a("code",[e._v("SparseTensor")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("ValueError")]),e._v(": If argument "),a("code",[e._v("shape")]),e._v(" requests a "),a("code",[e._v("SparseTensor")]),e._v(" with a different number of elements than "),a("code",[e._v("sp_input")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("ValueError")]),e._v(": If "),a("code",[e._v("shape")]),e._v(" has more than one inferred (== -1) dimension.")])])])}),[],!1,null,null,null);s.default=n.exports}}]);