(window.webpackJsonp=window.webpackJsonp||[]).push([[1842],{2033:function(e,t,a){"use strict";a.r(t);var s=a(0),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"class-auc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-auc","aria-hidden":"true"}},[e._v("#")]),e._v(" Class AUC")]),e._v(" "),a("p",[e._v("Computes the approximate AUC (Area under the curve) via a Riemann sum.\n"),a("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/keras/metrics/Metric",target:"_blank",rel:"noopener noreferrer"}},[e._v("Metric"),a("OutboundLink")],1),e._v("Inherits From:")]),e._v(" "),a("h3",{attrs:{id:"aliases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),a("ul",[a("li",[e._v("Class "),a("code",[e._v("tf.compat.v1.keras.metrics.AUC")])]),e._v(" "),a("li",[e._v("Class "),a("code",[e._v("tf.compat.v2.keras.metrics.AUC")])]),e._v(" "),a("li",[e._v("Class "),a("code",[e._v("tf.compat.v2.metrics.AUC")])]),e._v(" "),a("li",[e._v("Class "),a("code",[e._v("tf.metrics.AUC")])])]),e._v(" "),a("h3",{attrs:{id:"used-in-the-tutorials"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#used-in-the-tutorials","aria-hidden":"true"}},[e._v("#")]),e._v(" Used in the tutorials:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("C")]),e._v("l"),a("code",[e._v("a")]),e._v("s"),a("code",[e._v("s")]),e._v("i"),a("code",[e._v("f")]),e._v("i"),a("code",[e._v("c")]),e._v("a"),a("code",[e._v("t")]),e._v("i"),a("code",[e._v("o")]),e._v("n"),a("code"),e._v("o"),a("code",[e._v("n")]),e._v(" "),a("code",[e._v("i")]),e._v("m"),a("code",[e._v("b")]),e._v("a"),a("code",[e._v("l")]),e._v("a"),a("code",[e._v("n")]),e._v("c"),a("code",[e._v("e")]),e._v("d"),a("code"),e._v("d"),a("code",[e._v("a")]),e._v("t"),a("code",[e._v("a")])])]),e._v(" "),a("p",[e._v("This metric creates four local variables, true_positives, true_negatives, false_positives and false_negatives that are used to compute the AUC. To discretize the AUC curve, a linearly spaced set of thresholds is used to compute pairs of recall and precision values. The area under the ROC-curve is therefore computed using the height of the recall values by the false positive rate, while the area under the PR-curve is the computed using the height of the precision values by the recall.")]),e._v(" "),a("p",[e._v("This value is ultimately returned as auc, an idempotent operation that computes the area under a discretized curve of precision versus recall values (computed using the aforementioned variables). The num_thresholds variable controls the degree of discretization with larger numbers of thresholds more closely approximating the true AUC. The quality of the approximation may vary dramatically depending on num_thresholds. The thresholds parameter can be used to manually specify thresholds which split the predictions more evenly.")]),e._v(" "),a("p",[e._v("For best results, predictions should be distributed approximately uniformly in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC approximation may be poor if this is not the case. Setting summation_method to 'minoring' or 'majoring' can help quantify the error in the approximation by providing lower or upper bound estimate of the AUC.")]),e._v(" "),a("p",[e._v("If sample_weight is None, weights default to 1. Use sample_weight of 0 to mask values.")]),e._v(" "),a("h4",{attrs:{id:"usage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usage","aria-hidden":"true"}},[e._v("#")]),e._v(" Usage:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" m = tf.keras.metrics.AUC(num_thresholds=3)\nm.update_state([0, 0, 1, 1], [0, 0.5, 0.3, 0.9])\n\n# threshold values are [0 - 1e-7, 0.5, 1 + 1e-7]\n# tp = [2, 1, 0], fp = [2, 0, 0], fn = [0, 1, 2], tn = [0, 2, 2]\n# recall = [1, 0.5, 0], fp_rate = [1, 0, 0]\n# auc = ((((1+0.5)/2)*(1-0))+ (((0.5+0)/2)*(0-0))) = 0.75\n\nprint('Final result: ', m.result().numpy())  # Final result: 0.75\n")])])]),a("p",[e._v("Usage with tf.keras API:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" model = tf.keras.Model(inputs, outputs)\nmodel.compile('sgd', loss='mse', metrics=[tf.keras.metrics.AUC()])\n")])])]),a("h2",{attrs:{id:"init"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#init","aria-hidden":"true"}},[e._v("#")]),e._v(" "),a("strong",[e._v("init")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/keras/metrics.py#L1638-L1727",target:"_blank",rel:"noopener noreferrer"}},[e._v("View source"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" __init__(\n    num_thresholds=200,\n    curve='ROC',\n    summation_method='interpolation',\n    name=None,\n    dtype=None,\n    thresholds=None\n)\n")])])]),a("p",[e._v("Creates an AUC instance.")]),e._v(" "),a("h4",{attrs:{id:"args"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("num_thresholds")]),e._v(": (Optional) Defaults to 200. The number of thresholds to use when discretizing the roc curve. Values must be > 1.")]),e._v(" "),a("li",[a("code",[e._v("curve")]),e._v(": (Optional) Specifies the name of the "),a("code",[e._v("curve")]),e._v(" to be computed, 'ROC' [default] or 'PR' for the Precision-Recall-"),a("code",[e._v("curve")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("summation_method")]),e._v(": (Optional) Specifies the Riemann summation method used (https://en.wikipedia.org/wiki/Riemann_sum): 'interpolation' [default], applies mid-point summation scheme for "),a("code",[e._v("ROC")]),e._v(". For PR-AUC, interpolates (true/false) positives but not the ratio that is precision (see Davis & Goadrich 2006 for details); 'minoring' that applies left summation for increasing intervals and right summation for decreasing intervals; 'majoring' that does the opposite.")]),e._v(" "),a("li",[a("code",[e._v("name")]),e._v(": (Optional) string "),a("code",[e._v("name")]),e._v(" of the metric instance.")]),e._v(" "),a("li",[a("code",[e._v("dtype")]),e._v(": (Optional) data type of the metric result.")]),e._v(" "),a("li",[a("code",[e._v("thresholds")]),e._v(": (Optional) A list of floating point values to use as the "),a("code",[e._v("thresholds")]),e._v(" for discretizing the "),a("code",[e._v("curve")]),e._v(". If set, the "),a("code",[e._v("num_thresholds")]),e._v(" parameter is ignored. Values should be in [0, 1]. Endpoint "),a("code",[e._v("thresholds")]),e._v(" equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be automatically included with these to correctly handle predictions equal to exactly 0 or 1.")])]),e._v(" "),a("h2",{attrs:{id:"new"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new","aria-hidden":"true"}},[e._v("#")]),e._v(" "),a("strong",[e._v("new")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/keras/metrics.py#L144-L160",target:"_blank",rel:"noopener noreferrer"}},[e._v("View source"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" __new__(\n    cls,\n    *args,\n    **kwargs\n)\n")])])]),a("p",[e._v("Create and return a new object. See help(type) for accurate signature.")]),e._v(" "),a("h2",{attrs:{id:"methods"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#methods","aria-hidden":"true"}},[e._v("#")]),e._v(" Methods")]),e._v(" "),a("h3",{attrs:{id:"interpolate-pr-auc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interpolate-pr-auc","aria-hidden":"true"}},[e._v("#")]),e._v(" interpolate_pr_auc")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/keras/metrics.py#L1749-L1816",target:"_blank",rel:"noopener noreferrer"}},[e._v("View source"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" interpolate_pr_auc()\n")])])]),a("p",[e._v("Interpolation formula inspired by section 4 of Davis & Goadrich 2006.")]),e._v(" "),a("p",[e._v("https://www.biostat.wisc.edu/~page/rocpr.pdf")]),e._v(" "),a("p",[e._v("Note here we derive & use a closed formula not present in the paper as follows:")]),e._v(" "),a("p",[e._v("Precision = TP / (TP + FP) = TP / P")]),e._v(" "),a("p",[e._v("Modeling all of TP (true positive), FP (false positive) and their sum P = TP + FP (predicted positive) as varying linearly within each interval [A, B] between successive thresholds, we get")]),e._v(" "),a("p",[e._v("Precision slope = dTP / dP = (TP_B - TP_A) / (P_B - P_A) = (TP - TP_A) / (P - P_A) Precision = (TP_A + slope * (P - P_A)) / P")]),e._v(" "),a("p",[e._v("The area within the interval is (slope / total_pos_weight) times")]),e._v(" "),a("p",[e._v("int_A^B{Precision.dP} = int_A^B{(TP_A + slope * (P - P_A)) * dP / P} int_A^B{Precision.dP} = int_A^B{slope * dP + intercept * dP / P}")]),e._v(" "),a("p",[e._v("where intercept = TP_A - slope * P_A = TP_B - slope * P_B, resulting in")]),e._v(" "),a("p",[e._v("int_A^B{Precision.dP} = TP_B - TP_A + intercept * log(P_B / P_A)")]),e._v(" "),a("p",[e._v("Bringing back the factor (slope / total_pos_weight) we'd put aside, we get")]),e._v(" "),a("p",[e._v("slope * [dTP + intercept * log(P_B / P_A)] / total_pos_weight")]),e._v(" "),a("p",[e._v("where dTP == TP_B - TP_A.")]),e._v(" "),a("p",[e._v("Note that when P_A == 0 the above calculation simplifies into")]),e._v(" "),a("p",[e._v("int_A^B{Precision.dTP} = int_A^B{slope * dTP} = slope * (TP_B - TP_A)")]),e._v(" "),a("p",[e._v("which is really equivalent to imputing constant precision throughout the first bucket having >0 true positives.")]),e._v(" "),a("h4",{attrs:{id:"returns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("pr_auc")]),e._v(": an approximation of the area under the P-R curve.")])]),e._v(" "),a("h3",{attrs:{id:"reset-states"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reset-states","aria-hidden":"true"}},[e._v("#")]),e._v(" reset_states")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/keras/metrics.py#L1853-L1855",target:"_blank",rel:"noopener noreferrer"}},[e._v("View source"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" reset_states()\n")])])]),a("p",[e._v("Resets all of the metric state variables.")]),e._v(" "),a("p",[e._v("This function is called between epochs/steps, when a metric is evaluated during training.")]),e._v(" "),a("h3",{attrs:{id:"result"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#result","aria-hidden":"true"}},[e._v("#")]),e._v(" result")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/keras/metrics.py#L1818-L1851",target:"_blank",rel:"noopener noreferrer"}},[e._v("View source"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" result()\n")])])]),a("p",[e._v("Computes and returns the metric value tensor.")]),e._v(" "),a("p",[e._v("Result computation is an idempotent operation that simply calculates the metric value using the state variables.")]),e._v(" "),a("h3",{attrs:{id:"update-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#update-state","aria-hidden":"true"}},[e._v("#")]),e._v(" update_state")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/keras/metrics.py#L1729-L1747",target:"_blank",rel:"noopener noreferrer"}},[e._v("View source"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" update_state(\n    y_true,\n    y_pred,\n    sample_weight=None\n)\n")])])]),a("p",[e._v("Accumulates confusion matrix statistics.")]),e._v(" "),a("h4",{attrs:{id:"args-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#args-2","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("y_true")]),e._v(": The ground truth values.")]),e._v(" "),a("li",[a("code",[e._v("y_pred")]),e._v(": The predicted values.")]),e._v(" "),a("li",[a("code",[e._v("sample_weight")]),e._v(": Optional weighting of each example. Defaults to 1. Can be a "),a("code",[e._v("Tensor")]),e._v(" whose rank is either 0, or the same rank as "),a("code",[e._v("y_true")]),e._v(", and must be broadcastable to "),a("code",[e._v("y_true")]),e._v(".")])]),e._v(" "),a("h4",{attrs:{id:"returns-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-2","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),a("p",[e._v("Update op.")])])}),[],!1,null,null,null);t.default=r.exports}}]);