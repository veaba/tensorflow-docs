(window.webpackJsonp=window.webpackJsonp||[]).push([[681],{869:function(e,o,t){"use strict";t.r(o);var r=t(0),a=Object(r.a)({},(function(){var e=this,o=e.$createElement,t=e._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Computes the norm of vectors, matrices, and tensors. (deprecated arguments)")]),e._v(" "),t("h3",{attrs:{id:"aliases"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("tf.compat.v1.linalg.norm")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" tf.compat.v1.norm(\n    tensor,\n    ord='euclidean',\n    axis=None,\n    keepdims=None,\n    name=None,\n    keep_dims=None\n)\n")])])]),t("p",[e._v("This function can compute several different vector norms (the 1-norm, the Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0) and matrix norms (Frobenius, 1-norm, 2-norm and inf-norm).")]),e._v(" "),t("h4",{attrs:{id:"args"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("tensor")]),e._v(": "),t("code",[e._v("Tensor")]),e._v(" of types "),t("code",[e._v("float32")]),e._v(", "),t("code",[e._v("float64")]),e._v(", "),t("code",[e._v("complex64")]),e._v(", "),t("code",[e._v("complex128")])]),e._v(" "),t("li",[t("code",[e._v("ord")]),e._v(": Order of the norm. Supported values are '"),t("code",[e._v("fro")]),e._v("', 'euclidean', "),t("code",[e._v("1")]),e._v(", "),t("code",[e._v("2")]),e._v(", "),t("code",[e._v("np.inf")]),e._v(" and any positive real number yielding the corresponding p-norm. Default is 'euclidean' which is equivalent to Frobenius norm if "),t("code",[e._v("tensor")]),e._v(" is a matrix and equivalent to "),t("code",[e._v("2")]),e._v("-norm for vectors. Some restrictions apply: a) The Frobenius norm "),t("code",[e._v("fro")]),e._v(" is not defined for vectors, b) If "),t("code",[e._v("axis")]),e._v(" is a "),t("code",[e._v("2")]),e._v("-tuple (matrix norm), only 'euclidean', '"),t("code",[e._v("fro")]),e._v("', "),t("code",[e._v("1")]),e._v(", "),t("code",[e._v("2")]),e._v(", "),t("code",[e._v("np.inf")]),e._v(" are supported. See the description of "),t("code",[e._v("axis")]),e._v(" on how to compute norms for a batch of vectors or matrices stored in a "),t("code",[e._v("tensor")]),e._v(".")]),e._v(" "),t("li",[t("code",[e._v("axis")]),e._v(": If "),t("code",[e._v("axis")]),e._v(" is "),t("code",[e._v("None")]),e._v(" (the default), the input is considered a vector and a single vector norm is computed over the entire set of values in the "),t("code",[e._v("tensor")]),e._v(", i.e. norm("),t("code",[e._v("tensor")]),e._v(", "),t("code",[e._v("ord")]),e._v("="),t("code",[e._v("ord")]),e._v(") is equivalent to norm(reshape("),t("code",[e._v("tensor")]),e._v(", [-"),t("code",[e._v("1")]),e._v("]), "),t("code",[e._v("ord")]),e._v("="),t("code",[e._v("ord")]),e._v("). If "),t("code",[e._v("axis")]),e._v(" is a Python integer, the input is considered a batch of vectors, and "),t("code",[e._v("axis")]),e._v(" determines the "),t("code",[e._v("axis")]),e._v(" in "),t("code",[e._v("tensor")]),e._v(" over which to compute vector norms. If "),t("code",[e._v("axis")]),e._v(" is a "),t("code",[e._v("2")]),e._v("-tuple of Python integers it is considered a batch of matrices and "),t("code",[e._v("axis")]),e._v(" determines the axes in "),t("code",[e._v("tensor")]),e._v(" over which to compute a matrix norm. Negative indices are supported. Example: If you are passing a "),t("code",[e._v("tensor")]),e._v(" that can be either a matrix or a batch of matrices at runtime, pass "),t("code",[e._v("axis")]),e._v("=[-"),t("code",[e._v("2")]),e._v(",-"),t("code",[e._v("1")]),e._v("] instead of "),t("code",[e._v("axis")]),e._v("="),t("code",[e._v("None")]),e._v(" to make sure that matrix norms are computed.")]),e._v(" "),t("li",[t("code",[e._v("keepdims")]),e._v(": If True, the "),t("code",[e._v("axis")]),e._v(" indicated in "),t("code",[e._v("axis")]),e._v(" are kept with size "),t("code",[e._v("1")]),e._v(". Otherwise, the dimensions in "),t("code",[e._v("axis")]),e._v(" are removed "),t("code",[e._v("fro")]),e._v("m the output shape.")]),e._v(" "),t("li",[t("code",[e._v("name")]),e._v(": The "),t("code",[e._v("name")]),e._v(" of the op.")]),e._v(" "),t("li",[t("code",[e._v("keep_dims")]),e._v(": Deprecated alias for "),t("code",[e._v("keepdims")]),e._v(".")])]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("output")]),e._v(": A "),t("code",[e._v("Tensor")]),e._v(" of the same type as "),t("code",[e._v("tensor")]),e._v(", containing the vector or matrix norms. If "),t("code",[e._v("keepdims")]),e._v(" is True then the rank of "),t("code",[e._v("output")]),e._v(" is equal to the rank of "),t("code",[e._v("tensor")]),e._v(". Otherwise, if "),t("code",[e._v("axis")]),e._v(" is none the "),t("code",[e._v("output")]),e._v(" is a scalar, if "),t("code",[e._v("axis")]),e._v(" is an integer, the rank of "),t("code",[e._v("output")]),e._v(" is one less than the rank of "),t("code",[e._v("tensor")]),e._v(", if "),t("code",[e._v("axis")]),e._v(" is a 2-tuple the rank of "),t("code",[e._v("output")]),e._v(" is two less than the rank of "),t("code",[e._v("tensor")]),e._v(".")])]),e._v(" "),t("h4",{attrs:{id:"raises"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("ValueError")]),e._v(": If "),t("code",[e._v("ord")]),e._v(" or "),t("code",[e._v("axis")]),e._v(" is invalid.")])]),e._v(" "),t("h4",{attrs:{id:"numpy-compatibility"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#numpy-compatibility","aria-hidden":"true"}},[e._v("#")]),e._v(" Numpy Compatibility")]),e._v(" "),t("p",[e._v("Mostly equivalent to numpy.linalg.norm. Not supported: ord <= 0, 2-norm for matrices, nuclear norm. Other differences: a) If axis is None, treats the flattened tensor as a vector regardless of rank. b) Explicitly supports 'euclidean' norm as the default, including for higher order tensors.")])])}),[],!1,null,null,null);o.default=a.exports}}]);