(window.webpackJsonp=window.webpackJsonp||[]).push([[251],{436:function(e,_,t){"use strict";t.r(_);var a=t(0),o=Object(a.a)({},(function(){var e=this,_=e.$createElement,t=e._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Generates parsing spec for tf.parse_example to be used with classifiers.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" tf.compat.v1.estimator.classifier_parse_example_spec(\n    feature_columns,\n    label_key,\n    label_dtype=tf.dtypes.int64,\n    label_default=None,\n    weight_column=None\n)\n")])])]),t("p",[e._v("If users keep data in tf.Example format, they need to call tf.parse_example with a proper feature spec. There are two main things that this utility helps:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("U")]),e._v("s"),t("code",[e._v("e")]),e._v("r"),t("code",[e._v("s")]),e._v(" "),t("code",[e._v("n")]),e._v("e"),t("code",[e._v("e")]),e._v("d"),t("code"),e._v("t"),t("code",[e._v("o")]),e._v(" "),t("code",[e._v("c")]),e._v("o"),t("code",[e._v("m")]),e._v("b"),t("code",[e._v("i")]),e._v("n"),t("code",[e._v("e")]),e._v(" "),t("code",[e._v("p")]),e._v("a"),t("code",[e._v("r")]),e._v("s"),t("code",[e._v("i")]),e._v("n"),t("code",[e._v("g")]),e._v(" "),t("code",[e._v("s")]),e._v("p"),t("code",[e._v("e")]),e._v("c"),t("code"),e._v("o"),t("code",[e._v("f")]),e._v(" "),t("code",[e._v("f")]),e._v("e"),t("code",[e._v("a")]),e._v("t"),t("code",[e._v("u")]),e._v("r"),t("code",[e._v("e")]),e._v("s"),t("code"),e._v("w"),t("code",[e._v("i")]),e._v("t"),t("code",[e._v("h")]),e._v(" "),t("code",[e._v("l")]),e._v("a"),t("code",[e._v("b")]),e._v("e"),t("code",[e._v("l")]),e._v("s"),t("code"),e._v("a"),t("code",[e._v("n")]),e._v("d"),t("code"),e._v("w"),t("code",[e._v("e")]),e._v("i"),t("code",[e._v("g")]),e._v("h"),t("code",[e._v("t")]),e._v("s"),t("code"),e._v("("),t("code",[e._v("i")]),e._v("f"),t("code"),e._v("a"),t("code",[e._v("n")]),e._v("y"),t("code",[e._v(")")]),e._v(" "),t("code",[e._v("s")]),e._v("i"),t("code",[e._v("n")]),e._v("c"),t("code",[e._v("e")]),e._v(" "),t("code",[e._v("t")]),e._v("h"),t("code",[e._v("e")]),e._v("y"),t("code"),e._v("a"),t("code",[e._v("r")]),e._v("e"),t("code"),e._v("a"),t("code",[e._v("l")]),e._v("l"),t("code"),e._v("p"),t("code",[e._v("a")]),e._v("r"),t("code",[e._v("s")]),e._v("e"),t("code",[e._v("d")]),e._v(" "),t("code",[e._v("f")]),e._v("r"),t("code",[e._v("o")]),e._v("m"),t("code"),e._v("s"),t("code",[e._v("a")]),e._v("m"),t("code",[e._v("e")]),e._v(" "),t("code",[e._v("t")]),e._v("f"),t("code",[e._v(".")]),e._v("E"),t("code",[e._v("x")]),e._v("a"),t("code",[e._v("m")]),e._v("p"),t("code",[e._v("l")]),e._v("e"),t("code"),e._v("i"),t("code",[e._v("n")]),e._v("s"),t("code",[e._v("t")]),e._v("a"),t("code",[e._v("n")]),e._v("c"),t("code",[e._v("e")]),e._v("."),t("code"),e._v("T"),t("code",[e._v("h")]),e._v("i"),t("code",[e._v("s")]),e._v(" "),t("code",[e._v("u")]),e._v("t"),t("code",[e._v("i")]),e._v("l"),t("code",[e._v("i")]),e._v("t"),t("code",[e._v("y")]),e._v(" "),t("code",[e._v("c")]),e._v("o"),t("code",[e._v("m")]),e._v("b"),t("code",[e._v("i")]),e._v("n"),t("code",[e._v("e")]),e._v("s"),t("code"),e._v("t"),t("code",[e._v("h")]),e._v("e"),t("code",[e._v("s")]),e._v("e"),t("code"),e._v("s"),t("code",[e._v("p")]),e._v("e"),t("code",[e._v("c")]),e._v("s"),t("code",[e._v(".")])]),e._v(" "),t("li",[e._v("It is difficult to map expected label by a classifier such as "),t("code",[e._v("DNNClassifier")]),e._v(" to corresponding tf.parse_example spec. This utility encodes it by getting related information from users (key, dtype).")])]),e._v(" "),t("p",[e._v("Example output of parsing spec:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' # Define features and transformations\nfeature_b = tf.feature_column.numeric_column(...)\nfeature_c_bucketized = tf.feature_column.bucketized_column(\n  tf.feature_column.numeric_column("feature_c"), ...)\nfeature_a_x_feature_c = tf.feature_column.crossed_column(\n    columns=["feature_a", feature_c_bucketized], ...)\n\nfeature_columns = [feature_b, feature_c_bucketized, feature_a_x_feature_c]\nparsing_spec = tf.estimator.classifier_parse_example_spec(\n    feature_columns, label_key=\'my-label\', label_dtype=tf.string)\n\n# For the above example, classifier_parse_example_spec would return the dict:\nassert parsing_spec == {\n  "feature_a": parsing_ops.VarLenFeature(tf.string),\n  "feature_b": parsing_ops.FixedLenFeature([1], dtype=tf.float32),\n  "feature_c": parsing_ops.FixedLenFeature([1], dtype=tf.float32)\n  "my-label" : parsing_ops.FixedLenFeature([1], dtype=tf.string)\n}\n')])])]),t("p",[e._v("Example usage with a classifier:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" feature_columns = # define features via tf.feature_column\nestimator = DNNClassifier(\n    n_classes=1000,\n    feature_columns=feature_columns,\n    weight_column='example-weight',\n    label_vocabulary=['photos', 'keep', ...],\n    hidden_units=[256, 64, 16])\n# This label configuration tells the classifier the following:\n# * weights are retrieved with key 'example-weight'\n# * label is string and can be one of the following ['photos', 'keep', ...]\n# * integer id for label 'photos' is 0, 'keep' is 1, ...\n\n\n# Input builders\ndef input_fn_train():  # Returns a tuple of features and labels.\n  features = tf.contrib.learn.read_keyed_batch_features(\n      file_pattern=train_files,\n      batch_size=batch_size,\n      # creates parsing configuration for tf.parse_example\n      features=tf.estimator.classifier_parse_example_spec(\n          feature_columns,\n          label_key='my-label',\n          label_dtype=tf.string,\n          weight_column='example-weight'),\n      reader=tf.RecordIOReader)\n   labels = features.pop('my-label')\n   return features, labels\n\nestimator.train(input_fn=input_fn_train)\n")])])]),t("h4",{attrs:{id:"args"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("feature_columns")]),e._v(": An iterable containing all feature columns. All items should be instances of classes derived from "),t("code",[e._v("FeatureColumn")]),e._v(".")]),e._v(" "),t("li",[t("code",[e._v("label_key")]),e._v(": A string identifying the label. It means tf.Example stores labels with this key.")]),e._v(" "),t("li",[t("code",[e._v("label_dtype")]),e._v(": A "),t("code",[e._v("tf.dtype")]),e._v(" identifies the type of labels. By default it is "),t("code",[e._v("tf.int64")]),e._v(". If user defines a "),t("code",[e._v("label_vocabulary")]),e._v(", this should be set as "),t("code",[e._v("tf.string")]),e._v(". "),t("code",[e._v("tf.float32")]),e._v(" labels are only supported for binary classification.")]),e._v(" "),t("li",[t("code",[e._v("label_default")]),e._v(": used as label if "),t("code",[e._v("label_key")]),e._v(" does not exist in given tf.Example. An example usage: let's say "),t("code",[e._v("label_key")]),e._v(" is 'clicked' and tf.Example contains clicked data only for positive examples in following format "),t("code",[e._v("key:clicked, value:1")]),e._v(". This means that if there is no data with key 'clicked' it should count as negative example by setting "),t("code",[e._v("label_deafault=0")]),e._v(". Type of this value should be compatible with "),t("code",[e._v("label_dtype")]),e._v(".")]),e._v(" "),t("li",[t("code",[e._v("weight_column")]),e._v(": A string or a "),t("code",[e._v("NumericColumn")]),e._v(" created by "),t("code",[e._v("tf.feature_column.numeric_column")]),e._v(" defining feature column representing weights. It is used to down weight or boost examples during training. It will be multiplied by the loss of the example. If it is a string, it is used as a key to fetch weight tensor from the "),t("code",[e._v("features")]),e._v(". If it is a "),t("code",[e._v("NumericColumn")]),e._v(", raw tensor is fetched by key "),t("code",[e._v("weight_column")]),e._v(".key, then "),t("code",[e._v("weight_column")]),e._v(".normalizer_fn is applied on it to get weight tensor.")])]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),t("p",[e._v("A dict mapping each feature key to a FixedLenFeature or VarLenFeature value.")]),e._v(" "),t("h4",{attrs:{id:"raises"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("ValueError")]),e._v(": If label is used in "),t("code",[e._v("feature_columns")]),e._v(".")]),e._v(" "),t("li",[t("code",[e._v("ValueError")]),e._v(": If weight_column is used in "),t("code",[e._v("feature_columns")]),e._v(".")]),e._v(" "),t("li",[t("code",[e._v("ValueError")]),e._v(": If any of the given "),t("code",[e._v("feature_columns")]),e._v(" is not a "),t("code",[e._v("_FeatureColumn")]),e._v(" instance.")]),e._v(" "),t("li",[t("code",[e._v("ValueError")]),e._v(": If "),t("code",[e._v("weight_column")]),e._v(" is not a "),t("code",[e._v("NumericColumn")]),e._v(" instance.")]),e._v(" "),t("li",[t("code",[e._v("ValueError")]),e._v(": if label_key is None.")])])])}),[],!1,null,null,null);_.default=o.exports}}]);