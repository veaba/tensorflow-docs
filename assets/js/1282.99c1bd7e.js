(window.webpackJsonp=window.webpackJsonp||[]).push([[1282],{1470:function(e,t,a){"use strict";a.r(t);var r=a(0),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"class-linearsdca"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-linearsdca","aria-hidden":"true"}},[e._v("#")]),e._v(" Class LinearSDCA")]),e._v(" "),a("p",[e._v("Stochastic Dual Coordinate Ascent helper for linear estimators.")]),e._v(" "),a("h3",{attrs:{id:"aliases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),a("ul",[a("li",[e._v("Class "),a("code",[e._v("tf.compat.v1.estimator.experimental.LinearSDCA")])]),e._v(" "),a("li",[e._v("Class "),a("code",[e._v("tf.compat.v2.estimator.experimental.LinearSDCA")]),e._v(" "),a("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/estimator/LinearClassifier",target:"_blank",rel:"noopener noreferrer"}},[e._v("tf.estimator.LinearClassifier"),a("OutboundLink")],1),e._v("Objects of this class are intended to be provided as the optimizer argument (though LinearSDCA objects do not implement the tf.train.Optimizer interface) when creating  or tf.estimator.LinearRegressor.")])]),e._v(" "),a("p",[e._v("SDCA can only be used with LinearClassifier and LinearRegressor under the following conditions:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("F")]),e._v("e"),a("code",[e._v("a")]),e._v("t"),a("code",[e._v("u")]),e._v("r"),a("code",[e._v("e")]),e._v(" "),a("code",[e._v("c")]),e._v("o"),a("code",[e._v("l")]),e._v("u"),a("code",[e._v("m")]),e._v("n"),a("code",[e._v("s")]),e._v(" "),a("code",[e._v("a")]),e._v("r"),a("code",[e._v("e")]),e._v(" "),a("code",[e._v("o")]),e._v("f"),a("code"),e._v("t"),a("code",[e._v("y")]),e._v("p"),a("code",[e._v("e")]),e._v(" "),a("code",[e._v("V")]),e._v("2"),a("code",[e._v(".")])]),e._v(" "),a("li",[e._v("Multivalent categorical columns are not normalized. In other words the "),a("code",[e._v("sparse_combiner")]),e._v(' argument in the estimator constructor should be "sum".')]),e._v(" "),a("li",[e._v("For classification: binary label.")]),e._v(" "),a("li",[e._v("For regression: one-dimensional label.")])]),e._v(" "),a("h4",{attrs:{id:"example-usage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example-usage","aria-hidden":"true"}},[e._v("#")]),e._v(" Example usage:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" real_feature_column = numeric_column(...)\nsparse_feature_column = categorical_column_with_hash_bucket(...)\nlinear_sdca = tf.estimator.experimental.LinearSDCA(\n    example_id_column='example_id',\n    num_loss_partitions=1,\n    num_table_shards=1,\n    symmetric_l2_regularization=2.0)\nclassifier = tf.estimator.LinearClassifier(\n    feature_columns=[real_feature_column, sparse_feature_column],\n    weight_column=...,\n    optimizer=linear_sdca)\nclassifier.train(input_fn_train, steps=50)\nclassifier.evaluate(input_fn=input_fn_eval)\n")])])]),a("p",[a("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/estimator",target:"_blank",rel:"noopener noreferrer"}},[e._v("tf.estimator"),a("OutboundLink")],1),e._v("Here the expectation is that the input_fn_* functions passed to train and evaluate return a pair (dict, label_tensor) where dict has example_id_column as key whose value is a Tensor of shape [batch_size] and dtype string. num_loss_partitions defines sigma' in eq (11) of [3]. Convergence of (global) loss is guaranteed if num_loss_partitions is larger or equal to the product (#concurrent train ops/per worker) x (#workers). Larger values for num_loss_partitions lead to slower convergence. The recommended value for num_loss_partitions in  (where currently there is one process per worker) is the number of workers running the train steps. It defaults to 1 (single machine). num_table_shards defines the number of shards for the internal state table, typically set to match the number of parameter servers for large data sets.")]),e._v(" "),a("p",[e._v("The SDCA algorithm was originally introduced in [1] and it was followed by the L1 proximal step [2], a distributed version [3] and adaptive sampling [4]. [1] www.jmlr.org/papers/volume14/shalev-shwartz13a/shalev-shwartz13a.pdf [2] https://arxiv.org/pdf/1309.2375.pdf [3] https://arxiv.org/pdf/1502.03508.pdf [4] https://arxiv.org/pdf/1502.08053.pdf Details specific to this implementation are provided in: https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/canned/linear_optimizer/doc/sdca.ipynb")]),e._v(" "),a("h2",{attrs:{id:"init"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#init","aria-hidden":"true"}},[e._v("#")]),e._v(" "),a("strong",[e._v("init")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/canned/linear.py",target:"_blank",rel:"noopener noreferrer"}},[e._v("View source"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" __init__(\n    example_id_column,\n    num_loss_partitions=1,\n    num_table_shards=None,\n    symmetric_l1_regularization=0.0,\n    symmetric_l2_regularization=1.0,\n    adaptive=False\n)\n")])])]),a("p",[e._v("Construct a new SDCA optimizer for linear estimators.")]),e._v(" "),a("h4",{attrs:{id:"args"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("example_id_column")]),e._v(": The column name containing the example ids.")]),e._v(" "),a("li",[a("code",[e._v("num_loss_partitions")]),e._v(": Number of workers.")]),e._v(" "),a("li",[a("code",[e._v("num_table_shards")]),e._v(": Number of shards of the internal state table, typically set to match the number of parameter servers.")]),e._v(" "),a("li",[a("code",[e._v("symmetric_l1_regularization")]),e._v(": A float value, must be greater than or equal to zero.")]),e._v(" "),a("li",[a("code",[e._v("symmetric_l2_regularization")]),e._v(": A float value, must be greater than zero and should typically be greater than 1.")]),e._v(" "),a("li",[a("code",[e._v("adaptive")]),e._v(": A boolean indicating whether to use "),a("code",[e._v("adaptive")]),e._v(" sampling.")])]),e._v(" "),a("h2",{attrs:{id:"methods"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#methods","aria-hidden":"true"}},[e._v("#")]),e._v(" Methods")]),e._v(" "),a("h3",{attrs:{id:"get-train-step"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-train-step","aria-hidden":"true"}},[e._v("#")]),e._v(" get_train_step")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/canned/linear.py",target:"_blank",rel:"noopener noreferrer"}},[e._v("View source"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" get_train_step(\n    state_manager,\n    weight_column_name,\n    loss_type,\n    feature_columns,\n    features,\n    targets,\n    bias_var,\n    global_step\n)\n")])])]),a("p",[e._v("Returns the training operation of an SdcaModel optimizer.")])])}),[],!1,null,null,null);t.default=s.exports}}]);