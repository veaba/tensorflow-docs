(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{217:function(t,e,s){"use strict";s.r(e);var n=s(0),i=Object(n.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("Defined in generated file: python/ops/gen_bitwise_ops.py")]),t._v(" "),s("p",[t._v("Elementwise computes the bitwise right-shift of x and y.")]),t._v(" "),s("h3",{attrs:{id:"aliases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[t._v("#")]),t._v(" Aliases:")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("tf.compat.v1.bitwise.right_shift")])]),t._v(" "),s("li",[s("code",[t._v("tf.compat.v2.bitwise.right_shift")])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(" tf.bitwise.right_shift(\n    x,\n    y,\n    name=None\n)\n")])])]),s("p",[t._v("Performs a logical shift for unsigned integer types, and an arithmetic shift for signed integer types.")]),t._v(" "),s("p",[t._v("If y is negative, or greater than or equal to than the width of x in bits the result is implementation defined.")]),t._v(" "),s("h4",{attrs:{id:"example"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#example","aria-hidden":"true"}},[t._v("#")]),t._v(" Example:")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(" import tensorflow as tf\nfrom tensorflow.python.ops import bitwise_ops\nimport numpy as np\ndtype_list = [tf.int8, tf.int16, tf.int32, tf.int64]\n\nfor dtype in dtype_list:\n  lhs = tf.constant([-1, -5, -3, -14], dtype=dtype)\n  rhs = tf.constant([5, 0, 7, 11], dtype=dtype)\n  \n  right_shift_result = bitwise_ops.right_shift(lhs, rhs)\n  \n  print(right_shift_result)\n  \n# This will print:\n# tf.Tensor([-1 -5 -1 -1], shape=(4,), dtype=int8)\n# tf.Tensor([-1 -5 -1 -1], shape=(4,), dtype=int16)\n# tf.Tensor([-1 -5 -1 -1], shape=(4,), dtype=int32)\n# tf.Tensor([-1 -5 -1 -1], shape=(4,), dtype=int64)\n\nlhs = np.array([-2, 64, 101, 32], dtype=np.int8)\nrhs = np.array([-1, -5, -3, -14], dtype=np.int8)\nbitwise_ops.right_shift(lhs, rhs)\n# <tf.Tensor: id=151, shape=(4,), dtype=int8, numpy=array([ -2,  64, 101,  32], dtype=int8)>\n")])])]),s("h4",{attrs:{id:"args"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[t._v("#")]),t._v(" Args:")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("x")]),t._v(": A "),s("code",[t._v("Tensor")]),t._v(". Must be one of the following types: "),s("code",[t._v("int8")]),t._v(", "),s("code",[t._v("int16")]),t._v(", "),s("code",[t._v("int32")]),t._v(", "),s("code",[t._v("int64")]),t._v(", "),s("code",[t._v("uint8")]),t._v(", "),s("code",[t._v("uint16")]),t._v(", "),s("code",[t._v("uint32")]),t._v(", "),s("code",[t._v("uint64")]),t._v(".")]),t._v(" "),s("li",[s("code",[t._v("y")]),t._v(": A "),s("code",[t._v("Tensor")]),t._v(". Must have the same t"),s("code",[t._v("y")]),t._v("pe as "),s("code",[t._v("x")]),t._v(".")]),t._v(" "),s("li",[s("code",[t._v("name")]),t._v(": A "),s("code",[t._v("name")]),t._v(" for the operation (optional).")])]),t._v(" "),s("h4",{attrs:{id:"returns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[t._v("#")]),t._v(" Returns:")]),t._v(" "),s("p",[t._v("A Tensor. Has the same type as x.")])])}),[],!1,null,null,null);e.default=i.exports}}]);