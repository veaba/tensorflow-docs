(window.webpackJsonp=window.webpackJsonp||[]).push([[1398],{1589:function(e,o,t){"use strict";t.r(o);var _=t(0),v=Object(_.a)({},(function(){var e=this,o=e.$createElement,t=e._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Defined in generated file: python/ops/gen_decode_proto_ops.py")]),e._v(" "),t("p",[e._v("The op extracts fields from a serialized protocol buffers message into tensors.")]),e._v(" "),t("h3",{attrs:{id:"aliases"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("tf.compat.v1.io.decode_proto")])]),e._v(" "),t("li",[t("code",[e._v("tf.compat.v2.io.decode_proto")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" tf.io.decode_proto(\n    bytes,\n    message_type,\n    field_names,\n    output_types,\n    descriptor_source='local://',\n    message_format='binary',\n    sanitize=False,\n    name=None\n)\n")])])]),t("p",[e._v("The decode_proto op extracts fields from a serialized protocol buffers message into tensors. The fields in field_names are decoded and converted to the corresponding output_types if possible.")]),e._v(" "),t("p",[e._v("A message_type name must be provided to give context for the field names. The actual message descriptor can be looked up either in the linked-in descriptor pool or a filename provided by the caller using the descriptor_source attribute.")]),e._v(" "),t("p",[e._v("Each output tensor is a dense tensor. This means that it is padded to hold the largest number of repeated elements seen in the input minibatch. (The shape is also padded by one to prevent zero-sized dimensions). The actual repeat counts for each example in the minibatch can be found in the sizes output. In many cases the output of decode_proto is fed immediately into tf.squeeze if missing values are not a concern. When using tf.squeeze, always pass the squeeze dimension explicitly to avoid surprises.")]),e._v(" "),t("p",[e._v("For the most part, the mapping between Proto field types and TensorFlow dtypes is straightforward. However, there are a few special cases:")]),e._v(" "),t("ul",[t("li",[e._v("A proto field that contains a submessage or group can only be converted to "),t("code",[e._v("DT_STRING")]),e._v(" (the serialized submessage). This is to reduce the complexity of the API. The resulting string can be used as input to another instance of the decode_proto op.")]),e._v(" "),t("li",[e._v("TensorFlow lacks support for unsigned integers. The ops represent uint64 types as a "),t("code",[e._v("DT_INT64")]),e._v(" with the same twos-complement bit pattern (the obvious way). Unsigned int32 values can be represented exactly by specifying type "),t("code",[e._v("DT_INT64")]),e._v(", or using twos-complement if the caller specifies "),t("code",[e._v("DT_INT32")]),e._v(" in the "),t("code",[e._v("output_types")]),e._v(" attribute.")])]),e._v(" "),t("p",[e._v("Both binary and text proto serializations are supported, and can be chosen using the format attribute.")]),e._v(" "),t("p",[e._v("The descriptor_source attribute selects the source of protocol descriptors to consult when looking up message_type. This may be:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("A")]),e._v("n"),t("code"),e._v("e"),t("code",[e._v("m")]),e._v("p"),t("code",[e._v("t")]),e._v("y"),t("code"),e._v("s"),t("code",[e._v("t")]),e._v("r"),t("code",[e._v("i")]),e._v("n"),t("code",[e._v("g")]),e._v(" "),t("code",[e._v("o")]),e._v("r"),t("code"),e._v('"'),t("code",[e._v("l")]),e._v("o"),t("code",[e._v("c")]),e._v("a"),t("code",[e._v("l")]),e._v(":"),t("code",[e._v("/")]),e._v("/"),t("code",[e._v('"')]),e._v(","),t("code"),e._v("i"),t("code",[e._v("n")]),e._v(" "),t("code",[e._v("w")]),e._v("h"),t("code",[e._v("i")]),e._v("c"),t("code",[e._v("h")]),e._v(" "),t("code",[e._v("c")]),e._v("a"),t("code",[e._v("s")]),e._v("e"),t("code"),e._v("p"),t("code",[e._v("r")]),e._v("o"),t("code",[e._v("t")]),e._v("o"),t("code",[e._v("c")]),e._v("o"),t("code",[e._v("l")]),e._v(" "),t("code",[e._v("d")]),e._v("e"),t("code",[e._v("s")]),e._v("c"),t("code",[e._v("r")]),e._v("i"),t("code",[e._v("p")]),e._v("t"),t("code",[e._v("o")]),e._v("r"),t("code",[e._v("s")]),e._v(" "),t("code",[e._v("a")]),e._v("r"),t("code",[e._v("e")]),e._v(" "),t("code",[e._v("c")]),e._v("r"),t("code",[e._v("e")]),e._v("a"),t("code",[e._v("t")]),e._v("e"),t("code",[e._v("d")]),e._v(" "),t("code",[e._v("f")]),e._v("o"),t("code",[e._v("r")]),e._v(" "),t("code",[e._v("C")]),e._v("+"),t("code",[e._v("+")]),e._v(" "),t("code",[e._v("(")]),e._v("n"),t("code",[e._v("o")]),e._v("t"),t("code"),e._v("P"),t("code",[e._v("y")]),e._v("t"),t("code",[e._v("h")]),e._v("o"),t("code",[e._v("n")]),e._v(")"),t("code"),e._v("p"),t("code",[e._v("r")]),e._v("o"),t("code",[e._v("t")]),e._v("o"),t("code"),e._v("d"),t("code",[e._v("e")]),e._v("f"),t("code",[e._v("i")]),e._v("n"),t("code",[e._v("i")]),e._v("t"),t("code",[e._v("i")]),e._v("o"),t("code",[e._v("n")]),e._v("s"),t("code"),e._v("l"),t("code",[e._v("i")]),e._v("n"),t("code",[e._v("k")]),e._v("e"),t("code",[e._v("d")]),e._v(" "),t("code",[e._v("t")]),e._v("o"),t("code"),e._v("t"),t("code",[e._v("h")]),e._v("e"),t("code"),e._v("b"),t("code",[e._v("i")]),e._v("n"),t("code",[e._v("a")]),e._v("r"),t("code",[e._v("y")]),e._v(".``")]),e._v(" "),t("li",[e._v("A file, in which case "),t("code",[e._v("protoc")]),e._v("ol descriptors are created from the file, which is expected to contain a "),t("code",[e._v("FileDescriptorSet")]),e._v(" serialized as a string. NOTE: You can build a "),t("code",[e._v("descriptor_source")]),e._v(" file using the "),t("code",[e._v("--descriptor_set_out")]),e._v(" and "),t("code",[e._v("--include_imports")]),e._v(" options to the "),t("code",[e._v("protoc")]),e._v("ol compiler "),t("code",[e._v("protoc")]),e._v(".")]),e._v(" "),t("li",[e._v('A "bytes://", in which '),t("code",[e._v("protoc")]),e._v("ol descriptors are created from "),t("code",[e._v("<bytes>")]),e._v(", which is expected to be a "),t("code",[e._v("FileDescriptorSet")]),e._v(" serialized as a string.")])]),e._v(" "),t("h4",{attrs:{id:"args"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("bytes")]),e._v(": A "),t("code",[e._v("Tensor")]),e._v(" of type "),t("code",[e._v("string")]),e._v(". "),t("code",[e._v("Tensor")]),e._v(" of serialized protos with shape "),t("code",[e._v("batch_shape")]),e._v(".")]),e._v(" "),t("li",[t("code",[e._v("message_type")]),e._v(": A "),t("code",[e._v("string")]),e._v(". Name of the proto message type to decode.")]),e._v(" "),t("li",[t("code",[e._v("field_names")]),e._v(": A list of "),t("code",[e._v("string")]),e._v("s. List of "),t("code",[e._v("string")]),e._v("s containing proto field names. An extension field can be decoded by using its full name, e.g. EXT_PACKAGE.EXT_FIELD_NAME.")]),e._v(" "),t("li",[t("code",[e._v("output_types")]),e._v(": A list of "),t("code",[e._v("tf.DTypes")]),e._v(". List of TF types to use for the respective field in "),t("code",[e._v("field_names")]),e._v(".")]),e._v(" "),t("li",[t("code",[e._v("descriptor_source")]),e._v(": An optional "),t("code",[e._v("string")]),e._v(". Defaults to "),t("code",[e._v('"local://"')]),e._v(". Either the special value "),t("code",[e._v("local://")]),e._v(" or a path to a file containing a serialized "),t("code",[e._v("FileDescriptorSet")]),e._v(".")]),e._v(" "),t("li",[t("code",[e._v("message_format")]),e._v(": An optional "),t("code",[e._v("string")]),e._v(". Defaults to "),t("code",[e._v('"binary"')]),e._v(". Either "),t("code",[e._v("binary")]),e._v(" or "),t("code",[e._v("text")]),e._v(".")]),e._v(" "),t("li",[t("code",[e._v("sanitize")]),e._v(": An optional "),t("code",[e._v("bool")]),e._v(". Defaults to "),t("code",[e._v("False")]),e._v(". Whether to "),t("code",[e._v("sanitize")]),e._v(" the result or not.")]),e._v(" "),t("li",[t("code",[e._v("name")]),e._v(": A "),t("code",[e._v("name")]),e._v(" for the operation (optional).")])]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),t("p",[e._v("A tuple of Tensor objects (sizes, values).")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("sizes")]),e._v(": A "),t("code",[e._v("Tensor")]),e._v(" of type "),t("code",[e._v("int32")]),e._v(".")]),e._v(" "),t("li",[t("code",[e._v("values")]),e._v(": A list of "),t("code",[e._v("Tensor")]),e._v(" objects of type "),t("code",[e._v("output_types")]),e._v(".")])])])}),[],!1,null,null,null);o.default=v.exports}}]);