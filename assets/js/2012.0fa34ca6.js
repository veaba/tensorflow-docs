(window.webpackJsonp=window.webpackJsonp||[]).push([[2012],{2200:function(e,a,t){"use strict";t.r(a);var i=t(0),s=Object(i.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Computes the matrix exponential of one or more square matrices.")]),e._v(" "),t("h3",{attrs:{id:"aliases"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("tf.compat.v1.linalg.expm")])]),e._v(" "),t("li",[t("code",[e._v("tf.compat.v2.linalg.expm")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" tf.linalg.expm(\n    input,\n    name=None\n)\n")])])]),t("p",[e._v("exp(A) = \\sum_{n=0}^\\infty A^n/n!")]),e._v(" "),t("p",[e._v('The exponential is computed using a combination of the scaling and squaring method and the Pade approximation. Details can be found in: Nicholas J. Higham, "The scaling and squaring method for the matrix exponential revisited," SIAM J. Matrix Anal. Applic., 26:1179-1193, 2005.')]),e._v(" "),t("p",[e._v("The input is a tensor of shape [..., M, M] whose inner-most 2 dimensions form square matrices. The output is a tensor of the same shape as the input containing the exponential for all input submatrices [..., :, :].")]),e._v(" "),t("h4",{attrs:{id:"args"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("input")]),e._v(":"),t("code"),e._v("A"),t("code",[e._v("``Tensor``.`` ``M")]),e._v("ust"),t("code"),e._v("be"),t("code",[e._v("``float16``,`` ``float32``,`` ``float64``,`` ``complex64``,``")]),e._v("or"),t("code",[e._v("``complex128``")]),e._v("with"),t("code"),e._v("shape"),t("code"),e._v("["),t("code",[e._v(".``.``.``,`` ``M``,`` ``M")]),e._v("]"),t("code",[e._v(".")])]),e._v(" "),t("li",[t("code",[e._v("name")]),e._v(":"),t("code"),e._v("A"),t("code",[e._v("``name``")]),e._v("to"),t("code"),e._v("give"),t("code"),e._v("this"),t("code",[e._v("``Op``")]),e._v("(optional)"),t("code",[e._v(".")])])]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),t("p",[e._v("the matrix exponential of the input.")]),e._v(" "),t("h4",{attrs:{id:"raises"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("ValueError")]),e._v(": An unsupported type is provided as input.")])]),e._v(" "),t("h4",{attrs:{id:"scipy-compatibility"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scipy-compatibility","aria-hidden":"true"}},[e._v("#")]),e._v(" Scipy Compatibility")]),e._v(" "),t("p",[e._v("Equivalent to scipy.linalg.expm")])])}),[],!1,null,null,null);a.default=s.exports}}]);