(window.webpackJsonp=window.webpackJsonp||[]).push([[1785],{1976:function(e,t,s){"use strict";s.r(t);var a=s(0),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"class-rnn"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#class-rnn","aria-hidden":"true"}},[e._v("#")]),e._v(" Class RNN")]),e._v(" "),s("p",[e._v("Base class for recurrent layers.\n"),s("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/keras/layers/Layer",target:"_blank",rel:"noopener noreferrer"}},[e._v("Layer"),s("OutboundLink")],1),e._v("Inherits From:")]),e._v(" "),s("h3",{attrs:{id:"aliases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),s("ul",[s("li",[e._v("Class "),s("code",[e._v("tf.compat.v1.keras.layers.RNN")])]),e._v(" "),s("li",[e._v("Class "),s("code",[e._v("tf.compat.v2.keras.layers.RNN")])])]),e._v(" "),s("h3",{attrs:{id:"used-in-the-guide"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#used-in-the-guide","aria-hidden":"true"}},[e._v("#")]),e._v(" Used in the guide:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("R")]),e._v("e"),s("code",[e._v("c")]),e._v("u"),s("code",[e._v("r")]),e._v("r"),s("code",[e._v("e")]),e._v("n"),s("code",[e._v("t")]),e._v(" "),s("code",[e._v("N")]),e._v("e"),s("code",[e._v("u")]),e._v("r"),s("code",[e._v("a")]),e._v("l"),s("code"),e._v("N"),s("code",[e._v("e")]),e._v("t"),s("code",[e._v("w")]),e._v("o"),s("code",[e._v("r")]),e._v("k"),s("code",[e._v("s")]),e._v(" "),s("code",[e._v("(")]),e._v("R"),s("code",[e._v("N")]),e._v("N"),s("code",[e._v(")")]),e._v(" "),s("code",[e._v("w")]),e._v("i"),s("code",[e._v("t")]),e._v("h"),s("code"),e._v("K"),s("code",[e._v("e")]),e._v("r"),s("code",[e._v("a")]),e._v("s``")])]),e._v(" "),s("h4",{attrs:{id:"arguments"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arguments","aria-hidden":"true"}},[e._v("#")]),e._v(" Arguments:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("cell")]),e._v(": A RNN "),s("code",[e._v("cell")]),e._v(" instance or a list of RNN "),s("code",[e._v("cell")]),e._v(" instances. A RNN "),s("code",[e._v("cell")]),e._v(" is a class that has:\nA "),s("code",[e._v("call")]),e._v("(input_at_t, states_at_t) method, returning ("),s("code",[e._v("output_at_t, states_at_t_plus_1")]),e._v("). The "),s("code",[e._v("call")]),e._v(" method of the "),s("code",[e._v("cell")]),e._v(" can also take the optional argument "),s("code",[e._v("constants")]),e._v(', see section "Note on passing external '),s("code",[e._v("constants")]),e._v('" below.\nA '),s("code",[e._v("state_size")]),e._v(" attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The "),s("code",[e._v("state_size")]),e._v(" can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.\nA "),s("code",[e._v("output_size")]),e._v(" attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the "),s("code",[e._v("cell")]),e._v(", the value will be inferred by the first element of the "),s("code",[e._v("state_size")]),e._v(".\nA get_initial_state("),s("code",[e._v("inputs")]),e._v("="),s("code",[e._v("None")]),e._v(", "),s("code",[e._v("batch_size")]),e._v("="),s("code",[e._v("None")]),e._v(", "),s("code",[e._v("dtype")]),e._v("="),s("code",[e._v("None")]),e._v(") method that creates a tensor meant to be fed to "),s("code",[e._v("call")]),e._v("() as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of ["),s("code",[e._v("batch_size")]),e._v(", "),s("code",[e._v("cell")]),e._v("."),s("code",[e._v("state_size")]),e._v("]. The "),s("code",[e._v("cell")]),e._v(" might choose to create a tensor full of zeros, or full of other values based on the "),s("code",[e._v("cell")]),e._v("'s implementation. "),s("code",[e._v("inputs")]),e._v(" is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also "),s("code",[e._v("dtype")]),e._v(". Note that the shape[0] might be "),s("code",[e._v("None")]),e._v(" during the graph construction. Either the "),s("code",[e._v("inputs")]),e._v(" or the pair of "),s("code",[e._v("batch_size")]),e._v(" and "),s("code",[e._v("dtype")]),e._v(" are provided. "),s("code",[e._v("batch_size")]),e._v(" is a scalar tensor that represents the batch size of the "),s("code",[e._v("inputs")]),e._v(". "),s("code",[e._v("dtype")]),e._v(" is "),s("code",[e._v("tf.DType")]),e._v(" that represents the "),s("code",[e._v("dtype")]),e._v(" of the "),s("code",[e._v("inputs")]),e._v(". For backward compatible reason, if this method is not implemented by the "),s("code",[e._v("cell")]),e._v(", the RNN layer will create a zero filled tensor with the size of ["),s("code",[e._v("batch_size")]),e._v(", "),s("code",[e._v("cell")]),e._v("."),s("code",[e._v("state_size")]),e._v("]. In the case that "),s("code",[e._v("cell")]),e._v(" is a list of RNN "),s("code",[e._v("cell")]),e._v(" instances, the "),s("code",[e._v("cell")]),e._v("s will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN.")]),e._v(" "),s("li",[e._v("A "),s("code",[e._v("call")]),e._v("(input_at_t, states_at_t) method, returning ("),s("code",[e._v("output_at_t, states_at_t_plus_1")]),e._v("). The "),s("code",[e._v("call")]),e._v(" method of the "),s("code",[e._v("cell")]),e._v(" can also take the optional argument "),s("code",[e._v("constants")]),e._v(', see section "Note on passing external '),s("code",[e._v("constants")]),e._v('" below.')]),e._v(" "),s("li",[e._v("A "),s("code",[e._v("state_size")]),e._v(" attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The "),s("code",[e._v("state_size")]),e._v(" can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.")]),e._v(" "),s("li",[e._v("A "),s("code",[e._v("output_size")]),e._v(" attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the "),s("code",[e._v("cell")]),e._v(", the value will be inferred by the first element of the "),s("code",[e._v("state_size")]),e._v(".")]),e._v(" "),s("li",[e._v("A get_initial_state("),s("code",[e._v("inputs")]),e._v("="),s("code",[e._v("None")]),e._v(", "),s("code",[e._v("batch_size")]),e._v("="),s("code",[e._v("None")]),e._v(", "),s("code",[e._v("dtype")]),e._v("="),s("code",[e._v("None")]),e._v(") method that creates a tensor meant to be fed to "),s("code",[e._v("call")]),e._v("() as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of ["),s("code",[e._v("batch_size")]),e._v(", "),s("code",[e._v("cell")]),e._v("."),s("code",[e._v("state_size")]),e._v("]. The "),s("code",[e._v("cell")]),e._v(" might choose to create a tensor full of zeros, or full of other values based on the "),s("code",[e._v("cell")]),e._v("'s implementation. "),s("code",[e._v("inputs")]),e._v(" is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also "),s("code",[e._v("dtype")]),e._v(". Note that the shape[0] might be "),s("code",[e._v("None")]),e._v(" during the graph construction. Either the "),s("code",[e._v("inputs")]),e._v(" or the pair of "),s("code",[e._v("batch_size")]),e._v(" and "),s("code",[e._v("dtype")]),e._v(" are provided. "),s("code",[e._v("batch_size")]),e._v(" is a scalar tensor that represents the batch size of the "),s("code",[e._v("inputs")]),e._v(". "),s("code",[e._v("dtype")]),e._v(" is "),s("code",[e._v("tf.DType")]),e._v(" that represents the "),s("code",[e._v("dtype")]),e._v(" of the "),s("code",[e._v("inputs")]),e._v(". For backward compatible reason, if this method is not implemented by the "),s("code",[e._v("cell")]),e._v(", the RNN layer will create a zero filled tensor with the size of ["),s("code",[e._v("batch_size")]),e._v(", "),s("code",[e._v("cell")]),e._v("."),s("code",[e._v("state_size")]),e._v("]. In the case that "),s("code",[e._v("cell")]),e._v(" is a list of RNN "),s("code",[e._v("cell")]),e._v(" instances, the "),s("code",[e._v("cell")]),e._v("s will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN.")]),e._v(" "),s("li",[s("code",[e._v("return_sequences")]),e._v(": Boolean. Whether to return the last output in the output sequence, or the full sequence.")]),e._v(" "),s("li",[s("code",[e._v("return_state")]),e._v(": Boolean. Whether to return the last state in addition to the output.")]),e._v(" "),s("li",[s("code",[e._v("go_backwards")]),e._v(": Boolean (default False). If True, process the input sequence backwards and return the reversed sequence.")]),e._v(" "),s("li",[s("code",[e._v("stateful")]),e._v(": Boolean (default False). If True, the last state for each sample at index i in a batch will be used as initial state for the sample of index i in the following batch.")]),e._v(" "),s("li",[s("code",[e._v("unroll")]),e._v(": Boolean (default False). If True, the network will be "),s("code",[e._v("unroll")]),e._v("ed, else a symbolic loop will be used. Unrolling can speed-up a RNN, although it tends to be more memory-intensive. Unrolling is only suitable for short sequences.")]),e._v(" "),s("li",[s("code",[e._v("time_major")]),e._v(": The shape format of the "),s("code",[e._v("inputs")]),e._v(" and "),s("code",[e._v("outputs")]),e._v(" tensors. If True, the "),s("code",[e._v("inputs")]),e._v(" and "),s("code",[e._v("outputs")]),e._v(" will be in shape ("),s("code",[e._v("timesteps, batch, ...")]),e._v("), whereas in the False case, it will be ("),s("code",[e._v("batch, timesteps, ...")]),e._v("). Using "),s("code",[e._v("time_major")]),e._v(" = True is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.")])]),e._v(" "),s("h4",{attrs:{id:"call-arguments"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#call-arguments","aria-hidden":"true"}},[e._v("#")]),e._v(" Call arguments:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("inputs")]),e._v(": Input tensor.")]),e._v(" "),s("li",[s("code",[e._v("mask")]),e._v(": Binary tensor of shape ("),s("code",[e._v("samples, timesteps")]),e._v(") indicating whether a given timestep should be "),s("code",[e._v("mask")]),e._v("ed.")]),e._v(" "),s("li",[s("code",[e._v("training")]),e._v(": Python boolean indicating whether the layer should behave in "),s("code",[e._v("training")]),e._v(" mode or in inference mode. This argument is passed to the cell when calling it. This is for use with cells that use dropout.")]),e._v(" "),s("li",[s("code",[e._v("initial_state")]),e._v(": List of initial state tensors to be passed to the first call of the cell.")]),e._v(" "),s("li",[s("code",[e._v("constants")]),e._v(": List of constant tensors to be passed to the cell at each timestep.")])]),e._v(" "),s("h4",{attrs:{id:"input-shape"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#input-shape","aria-hidden":"true"}},[e._v("#")]),e._v(" Input shape:")]),e._v(" "),s("p",[e._v("N-D tensor with shape (batch_size, timesteps, ...) or (timesteps, batch_size, ...) when time_major is True.")]),e._v(" "),s("h4",{attrs:{id:"output-shape"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#output-shape","aria-hidden":"true"}},[e._v("#")]),e._v(" Output shape:")]),e._v(" "),s("ul",[s("li",[e._v("If "),s("code",[e._v("return_state")]),e._v(": a list of tensors. The first tensor is the output. The remaining tensors are the last states, each with shape ("),s("code",[e._v("batch_size, state_size")]),e._v("), where "),s("code",[e._v("state_size")]),e._v(" could be a high dimension tensor shape.")]),e._v(" "),s("li",[e._v("If "),s("code",[e._v("return_sequences")]),e._v(": N-D tensor with shape ("),s("code",[e._v("batch_size, timesteps, output_size")]),e._v("), where "),s("code",[e._v("output_size")]),e._v(" could be a high dimension tensor shape, or ("),s("code",[e._v("timesteps, batch_size, output_size")]),e._v(") when "),s("code",[e._v("time_major")]),e._v(" is True.")]),e._v(" "),s("li",[e._v("Else, N-D tensor with shape ("),s("code",[e._v("batch_size, output_size")]),e._v("), where "),s("code",[e._v("output_size")]),e._v(" could be a high dimension tensor shape.")])]),e._v(" "),s("h4",{attrs:{id:"masking"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#masking","aria-hidden":"true"}},[e._v("#")]),e._v(" Masking:")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/keras/layers/embeddings",target:"_blank",rel:"noopener noreferrer"}},[e._v("Embedding"),s("OutboundLink")],1),e._v("This layer supports masking for input data with a variable number of timesteps. To introduce masks to your data, use an  layer with the mask_zero parameter set to True.")]),e._v(" "),s("p",[e._v("Note on using statefulness in RNNs: You can set RNN layers to be 'stateful', which means that the states computed for the samples in one batch will be reused as initial states for the samples in the next batch. This assumes a one-to-one mapping between samples in different successive batches.")]),e._v(" "),s("p",[e._v("To enable statefulness: - Specify stateful=True in the layer constructor. - Specify a fixed batch size for your model, by passing If sequential model: batch_input_shape=(...) to the first layer in your model. Else for functional model with 1 or more Input layers: batch_shape=(...) to all the first layers in your model. This is the expected shape of your inputs including the batch size. It should be a tuple of integers, e.g. (32, 10, 100). - Specify shuffle=False when calling fit().")]),e._v(" "),s("p",[e._v("To reset the states of your model, call .reset_states() on either a specific layer, or on your entire model.")]),e._v(" "),s("p",[e._v("Note on specifying the initial state of RNNs: You can specify the initial state of RNN layers symbolically by calling them with the keyword argument initial_state. The value of initial_state should be a tensor or list of tensors representing the initial state of the RNN layer.")]),e._v(" "),s("p",[e._v("You can specify the initial state of RNN layers numerically by calling reset_states with the keyword argument states. The value of states should be a numpy array or list of numpy arrays representing the initial state of the RNN layer.\n"),s("a",{attrs:{href:"https://www.tensorflow.org/api_docs/python/tf/keras/layers/RNN#__call__",target:"_blank",rel:"noopener noreferrer"}},[e._v("RNN.call"),s("OutboundLink")],1),e._v('Note on passing external constants to RNNs: You can pass "external" constants to the cell using the constants keyword argument of  (as well as ) method. This requires that the cell.call method accepts the same keyword argument constants. Such constants can be used to condition the cell transformation on additional static inputs (not changing over time), a.k.a. an attention mechanism.')]),e._v(" "),s("h4",{attrs:{id:"examples"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#examples","aria-hidden":"true"}},[e._v("#")]),e._v(" Examples:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" # First, let's define a RNN Cell, as a layer subclass.\n\nclass MinimalRNNCell(keras.layers.Layer):\n\n    def __init__(self, units, **kwargs):\n        self.units = units\n        self.state_size = units\n        super(MinimalRNNCell, self).__init__(**kwargs)\n\n    def build(self, input_shape):\n        self.kernel = self.add_weight(shape=(input_shape[-1], self.units),\n                                      initializer='uniform',\n                                      name='kernel')\n        self.recurrent_kernel = self.add_weight(\n            shape=(self.units, self.units),\n            initializer='uniform',\n            name='recurrent_kernel')\n        self.built = True\n\n    def call(self, inputs, states):\n        prev_output = states[0]\n        h = K.dot(inputs, self.kernel)\n        output = h + K.dot(prev_output, self.recurrent_kernel)\n        return output, [output]\n\n# Let's use this cell in a RNN layer:\n\ncell = MinimalRNNCell(32)\nx = keras.Input((None, 5))\nlayer = RNN(cell)\ny = layer(x)\n\n# Here's how to use the cell to build a stacked RNN:\n\ncells = [MinimalRNNCell(32), MinimalRNNCell(64)]\nx = keras.Input((None, 5))\nlayer = RNN(cells)\ny = layer(x)\n")])])]),s("h2",{attrs:{id:"init"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#init","aria-hidden":"true"}},[e._v("#")]),e._v(" "),s("strong",[e._v("init")])]),e._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/keras/layers/recurrent.py#L366-L412",target:"_blank",rel:"noopener noreferrer"}},[e._v("View source"),s("OutboundLink")],1)]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" __init__(\n    cell,\n    return_sequences=False,\n    return_state=False,\n    go_backwards=False,\n    stateful=False,\n    unroll=False,\n    time_major=False,\n    **kwargs\n)\n")])])]),s("h2",{attrs:{id:"properties"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#properties","aria-hidden":"true"}},[e._v("#")]),e._v(" Properties")]),e._v(" "),s("h3",{attrs:{id:"states"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#states","aria-hidden":"true"}},[e._v("#")]),e._v(" states")]),e._v(" "),s("h2",{attrs:{id:"methods"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#methods","aria-hidden":"true"}},[e._v("#")]),e._v(" Methods")]),e._v(" "),s("h3",{attrs:{id:"get-initial-state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get-initial-state","aria-hidden":"true"}},[e._v("#")]),e._v(" get_initial_state")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/keras/layers/recurrent.py#L593-L614",target:"_blank",rel:"noopener noreferrer"}},[e._v("View source"),s("OutboundLink")],1)]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" get_initial_state(inputs)\n")])])]),s("h3",{attrs:{id:"reset-states"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reset-states","aria-hidden":"true"}},[e._v("#")]),e._v(" reset_states")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/keras/layers/recurrent.py#L806-L858",target:"_blank",rel:"noopener noreferrer"}},[e._v("View source"),s("OutboundLink")],1)]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" reset_states(states=None)\n")])])])])}),[],!1,null,null,null);t.default=o.exports}}]);