(window.webpackJsonp=window.webpackJsonp||[]).push([[1392],{1582:function(e,t,a){"use strict";a.r(t);var s=a(0),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Convert CSV records to tensors. Each column maps to one tensor.")]),e._v(" "),a("h3",{attrs:{id:"aliases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("tf.compat.v2.io.decode_csv")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" tf.io.decode_csv(\n    records,\n    record_defaults,\n    field_delim=',',\n    use_quote_delim=True,\n    na_value='',\n    select_cols=None,\n    name=None\n)\n")])])]),a("p",[e._v("RFC 4180 format is expected for the CSV records. (https://tools.ietf.org/html/rfc4180) Note that we allow leading and trailing spaces with int or float field.")]),e._v(" "),a("h4",{attrs:{id:"args"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("records")]),e._v(": A "),a("code",[e._v("Tensor")]),e._v(" of type "),a("code",[e._v("string")]),e._v(". Each "),a("code",[e._v("string")]),e._v(" is a record/row in the csv and all "),a("code",[e._v("records")]),e._v(" should have the same format.")]),e._v(" "),a("li",[a("code",[e._v("record_defaults")]),e._v(": A list of "),a("code",[e._v("Tensor")]),e._v(" objects with specific types. Acceptable types are "),a("code",[e._v("float32")]),e._v(", "),a("code",[e._v("float64")]),e._v(", "),a("code",[e._v("int32")]),e._v(", "),a("code",[e._v("int64")]),e._v(", "),a("code",[e._v("string")]),e._v(". One tensor per column of the input record, with either a scalar default value for that column or an empty vector if the column is required.")]),e._v(" "),a("li",[a("code",[e._v("field_delim")]),e._v(": An optional "),a("code",[e._v("string")]),e._v(". Defaults to "),a("code",[e._v('","')]),e._v(". char delimiter to separate fields in a record.")]),e._v(" "),a("li",[a("code",[e._v("use_quote_delim")]),e._v(": An optional "),a("code",[e._v("bool")]),e._v(". Defaults to "),a("code",[e._v("True")]),e._v(". If false, treats double quotation marks as regular characters inside of the "),a("code",[e._v("string")]),e._v(" fields (ignoring RFC 4180, Section 2, Bullet 5).")]),e._v(" "),a("li",[a("code",[e._v("na_value")]),e._v(": Additional "),a("code",[e._v("string")]),e._v(" to recognize as NA/NaN.")]),e._v(" "),a("li",[a("code",[e._v("select_cols")]),e._v(": Optional sorted list of column indices to select. If specified, only this subset of columns will be parsed and returned.")]),e._v(" "),a("li",[a("code",[e._v("name")]),e._v(": A "),a("code",[e._v("name")]),e._v(" for the operation (optional).")])]),e._v(" "),a("h4",{attrs:{id:"returns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),a("p",[e._v("A list of Tensor objects. Has the same type as record_defaults. Each tensor will have the same shape as records.")]),e._v(" "),a("h4",{attrs:{id:"raises"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("ValueError")]),e._v(": If any of the arguments is malformed.")])])])}),[],!1,null,null,null);t.default=o.exports}}]);