(window.webpackJsonp=window.webpackJsonp||[]).push([[785],{973:function(e,s,a){"use strict";a.r(s);var t=a(0),o=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Combines a batch of feature ids and values into a single SparseTensor. (deprecated)")]),e._v(" "),a("h3",{attrs:{id:"aliases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("tf.compat.v1.sparse.merge")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" tf.compat.v1.sparse_merge(\n    sp_ids,\n    sp_values,\n    vocab_size,\n    name=None,\n    already_sorted=False\n)\n")])])]),a("p",[e._v("The most common use case for this function occurs when feature ids and their corresponding values are stored in Example protos on disk. parse_example will return a batch of ids and a batch of values, and this function joins them into a single logical SparseTensor for use in functions such as sparse_tensor_dense_matmul, sparse_to_dense, etc.")]),e._v(" "),a("p",[e._v("The SparseTensor returned by this function has the following properties:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("indices")]),e._v(" is equivalent to "),a("code",[e._v("sp_ids.indices")]),e._v(" with the last dimension discarded and replaced with "),a("code",[e._v("sp_ids.values")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("values")]),e._v(" is simply "),a("code",[e._v("sp_values.values")]),e._v(".")]),e._v(" "),a("li",[e._v("If sp_ids.dense_shape = [D0, D1, ..., Dn, K], then output.shape = [D0, D1, ..., Dn, vocab_size].")])]),e._v(" "),a("p",[e._v("For example, consider the following feature vectors:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("   vector1 = [-3, 0, 0, 0, 0, 0]\n  vector2 = [ 0, 1, 0, 4, 1, 0]\n  vector3 = [ 5, 0, 0, 9, 0, 0]\n")])])]),a("p",[e._v("These might be stored sparsely in the following Example protos by storing only the feature ids (column number if the vectors are treated as a matrix) of the non-zero elements and the corresponding values:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('   examples = [Example(features={\n                  "ids": Feature(int64_list=Int64List(value=[0])),\n                  "values": Feature(float_list=FloatList(value=[-3]))}),\n              Example(features={\n                  "ids": Feature(int64_list=Int64List(value=[1, 4, 3])),\n                  "values": Feature(float_list=FloatList(value=[1, 1, 4]))}),\n              Example(features={\n                  "ids": Feature(int64_list=Int64List(value=[0, 3])),\n                  "values": Feature(float_list=FloatList(value=[5, 9]))})]\n')])])]),a("p",[e._v('The result of calling parse_example on these examples will produce a dictionary with entries for "ids" and "values". Passing those two objects to this function along with vocab_size=6, will produce a SparseTensor that sparsely represents all three instances. Namely, the indices property will contain the coordinates of the non-zero entries in the feature matrix (the first dimension is the row number in the matrix, i.e., the index within the batch, and the second dimension is the column number, i.e., the feature id); values will contain the actual values. shape will be the shape of the original matrix, i.e., (3, 6). For our example above, the output will be equal to:')]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("   SparseTensor(indices=[[0, 0], [1, 1], [1, 3], [1, 4], [2, 0], [2, 3]],\n               values=[-3, 1, 4, 1, 5, 9],\n               dense_shape=[3, 6])\n")])])]),a("p",[e._v("This method generalizes to higher-dimensions by simply providing a list for both the sp_ids as well as the vocab_size. In this case the resulting SparseTensor has the following properties: - indices is equivalent to sp_ids[0].indices with the last dimension discarded and concatenated with sp_ids[0].values, sp_ids[1].values, .... - values is simply sp_values.values. - If sp_ids.dense_shape = [D0, D1, ..., Dn, K], then output.shape = [D0, D1, ..., Dn] + vocab_size.")]),e._v(" "),a("h4",{attrs:{id:"args"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("sp_ids")]),e._v(": A single "),a("code",[e._v("SparseTensor")]),e._v(" with "),a("code",[e._v("values")]),e._v(" property of type "),a("code",[e._v("int32")]),e._v(" or "),a("code",[e._v("int64")]),e._v(" or a Python list of such "),a("code",[e._v("SparseTensor")]),e._v("s or a list thereof.")]),e._v(" "),a("li",[a("code",[e._v("sp_values")]),e._v(": A "),a("code",[e._v("SparseTensor")]),e._v(" of any type.")]),e._v(" "),a("li",[a("code",[e._v("vocab_size")]),e._v(": A scalar "),a("code",[e._v("int64")]),e._v(" Tensor (or Python "),a("code",[e._v("i")]),e._v("nt) conta"),a("code",[e._v("i")]),e._v("n"),a("code",[e._v("i")]),e._v("ng the new s"),a("code",[e._v("i")]),e._v("ze of the last d"),a("code",[e._v("i")]),e._v("mens"),a("code",[e._v("i")]),e._v("on, all(0 <= "),a("code",[e._v("sp_ids")]),e._v("."),a("code",[e._v("values")]),e._v(" < "),a("code",[e._v("vocab_size")]),e._v("). Or a l"),a("code",[e._v("i")]),e._v("st thereof w"),a("code",[e._v("i")]),e._v("th all(0 <= "),a("code",[e._v("sp_ids")]),e._v("["),a("code",[e._v("i")]),e._v("]."),a("code",[e._v("values")]),e._v(" < "),a("code",[e._v("vocab_size")]),e._v("["),a("code",[e._v("i")]),e._v("]) for all "),a("code",[e._v("i")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("name")]),e._v(": A "),a("code",[e._v("name")]),e._v(" pref"),a("code",[e._v("i")]),e._v("x for the returned tensors (opt"),a("code",[e._v("i")]),e._v("onal)")]),e._v(" "),a("li",[a("code",[e._v("already_sorted")]),e._v(": A boolean to spec"),a("code",[e._v("i")]),e._v("fy whether the per-batch "),a("code",[e._v("values")]),e._v(" "),a("code",[e._v("i")]),e._v("n "),a("code",[e._v("sp_values")]),e._v(" are already sorted. If so sk"),a("code",[e._v("i")]),e._v("p sort"),a("code",[e._v("i")]),e._v("ng, False by default (opt"),a("code",[e._v("i")]),e._v("onal).")])]),e._v(" "),a("h4",{attrs:{id:"returns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),a("p",[e._v("A SparseTensor compactly representing a batch of feature ids and values, useful for passing to functions that expect such a SparseTensor.")]),e._v(" "),a("h4",{attrs:{id:"raises"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("TypeError")]),e._v(": If "),a("code",[e._v("sp_values")]),e._v(" is not a "),a("code",[e._v("SparseTensor")]),e._v(". Or if "),a("code",[e._v("sp_ids")]),e._v(" is neither a "),a("code",[e._v("SparseTensor")]),e._v(" nor a list thereof. Or if "),a("code",[e._v("vocab_size")]),e._v(" is not a "),a("code",[e._v("Tensor")]),e._v(" or a Python int and "),a("code",[e._v("sp_ids")]),e._v(" is a "),a("code",[e._v("SparseTensor")]),e._v(". Or if "),a("code",[e._v("vocab_size")]),e._v(" is not a or list thereof and "),a("code",[e._v("sp_ids")]),e._v(" is a list.")]),e._v(" "),a("li",[a("code",[e._v("ValueError")]),e._v(": If "),a("code",[e._v("sp_ids")]),e._v(" and "),a("code",[e._v("vocab_size")]),e._v(" are lists of different lengths.")])])])}),[],!1,null,null,null);s.default=o.exports}}]);