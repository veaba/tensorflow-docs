(window.webpackJsonp=window.webpackJsonp||[]).push([[1288],{1477:function(e,t,s){"use strict";s.r(t);var a=s(0),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("Creates early-stopping hook.")]),e._v(" "),s("h3",{attrs:{id:"aliases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("tf.compat.v1.estimator.experimental.make_early_stopping_hook")])]),e._v(" "),s("li",[s("code",[e._v("tf.compat.v2.estimator.experimental.make_early_stopping_hook")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" tf.estimator.experimental.make_early_stopping_hook(\n    estimator,\n    should_stop_fn,\n    run_every_secs=60,\n    run_every_steps=None\n)\n")])])]),s("p",[e._v("Returns a SessionRunHook that stops training when should_stop_fn returns True.")]),e._v(" "),s("h4",{attrs:{id:"usage-example"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usage-example","aria-hidden":"true"}},[e._v("#")]),e._v(" Usage example:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" estimator = ...\nhook = early_stopping.make_early_stopping_hook(\n    estimator, should_stop_fn=make_stop_fn(...))\ntrain_spec = tf.estimator.TrainSpec(..., hooks=[hook])\ntf.estimator.train_and_evaluate(estimator, train_spec, ...)\n")])])]),s("p",[e._v("Caveat: Current implementation supports early-stopping both training and evaluation in local mode. In distributed mode, training can be stopped but evaluation (where it's a separate job) will indefinitely wait for new model checkpoints to evaluate, so you will need other means to detect and stop it. Early-stopping evaluation in distributed mode requires changes in train_and_evaluate API and will be addressed in a future revision.")]),e._v(" "),s("h4",{attrs:{id:"args"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("estimator")]),e._v(": A "),s("code",[e._v("tf.estimator.Estimator")]),e._v(" instance.")]),e._v(" "),s("li",[s("code",[e._v("should_stop_fn")]),e._v(": "),s("code",[e._v("callable")]),e._v(", function that takes no arguments and returns a "),s("code",[e._v("bool")]),e._v(". If the function returns "),s("code",[e._v("True")]),e._v(", stopping will be initiated by the chief.")]),e._v(" "),s("li",[s("code",[e._v("run_every_secs")]),e._v(": If specified, calls "),s("code",[e._v("should_stop_fn")]),e._v(" at an interval of "),s("code",[e._v("run_every_secs")]),e._v(" seconds. Defaults to 60 seconds. Either this or "),s("code",[e._v("run_every_steps")]),e._v(" must be set.")]),e._v(" "),s("li",[s("code",[e._v("run_every_steps")]),e._v(": If specified, calls "),s("code",[e._v("should_stop_fn")]),e._v(" every "),s("code",[e._v("run_every_steps")]),e._v(" steps. Either this or "),s("code",[e._v("run_every_secs")]),e._v(" must be set.")])]),e._v(" "),s("h4",{attrs:{id:"returns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),s("p",[e._v("A SessionRunHook that periodically executes should_stop_fn and initiates early stopping if the function returns True.")]),e._v(" "),s("h4",{attrs:{id:"raises"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("TypeError")]),e._v(": If "),s("code",[e._v("estimator")]),e._v(" is not of type "),s("code",[e._v("tf.estimator.Estimator")]),e._v(".")]),e._v(" "),s("li",[s("code",[e._v("ValueError")]),e._v(": If both "),s("code",[e._v("run_every_secs")]),e._v(" and "),s("code",[e._v("run_every_steps")]),e._v(" are set.")])])])}),[],!1,null,null,null);t.default=r.exports}}]);