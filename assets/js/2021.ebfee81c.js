(window.webpackJsonp=window.webpackJsonp||[]).push([[2021],{2212:function(e,a,t){"use strict";t.r(a);var o=t(0),s=Object(o.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Multiplies matrix a by vector b, producing a * b.")]),e._v(" "),t("h3",{attrs:{id:"aliases"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("tf.compat.v1.linalg.matvec")])]),e._v(" "),t("li",[t("code",[e._v("tf.compat.v2.linalg.matvec")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" tf.linalg.matvec(\n    a,\n    b,\n    transpose_a=False,\n    adjoint_a=False,\n    a_is_sparse=False,\n    b_is_sparse=False,\n    name=None\n)\n")])])]),t("p",[e._v("The matrix a must, following any transpositions, be a tensor of rank >= 2, and we must have shape(b) = shape(a)[:-2] + [shape(a)[-1]].")]),e._v(" "),t("p",[e._v("Both a and b must be of the same type. The supported types are: float16, float32, float64, int32, complex64, complex128.")]),e._v(" "),t("p",[e._v("Matrix a can be transposed or adjointed (conjugated and transposed) on the fly by setting one of the corresponding flag to True. These are False by default.")]),e._v(" "),t("p",[e._v("If one or both of the inputs contain a lot of zeros, a more efficient multiplication algorithm can be used by setting the corresponding a_is_sparse or b_is_sparse flag to True. These are False by default. This optimization is only available for plain matrices/vectors (rank-2/1 tensors) with datatypes bfloat16 or float32.")]),e._v(" "),t("h4",{attrs:{id:"for-example"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for-example","aria-hidden":"true"}},[e._v("#")]),e._v(" For example:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" # 2-D tensor `a`\n# [[1, 2, 3],\n#  [4, 5, 6]]\na = tf.constant([1, 2, 3, 4, 5, 6], shape=[2, 3])\n\n# 1-D tensor `b`\n# [7, 9, 11]\nb = tf.constant([7, 9, 11], shape=[3])\n\n# `a` * `b`\n# [ 58,  64]\nc = tf.matvec(a, b)\n\n\n# 3-D tensor `a`\n# [[[ 1,  2,  3],\n#   [ 4,  5,  6]],\n#  [[ 7,  8,  9],\n#   [10, 11, 12]]]\na = tf.constant(np.arange(1, 13, dtype=np.int32),\n                shape=[2, 2, 3])\n\n# 2-D tensor `b`\n# [[13, 14, 15],\n#  [16, 17, 18]]\nb = tf.constant(np.arange(13, 19, dtype=np.int32),\n                shape=[2, 3])\n\n# `a` * `b`\n# [[ 86, 212],\n#  [410, 563]]\nc = tf.matvec(a, b)\n")])])]),t("h4",{attrs:{id:"args"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("a")]),e._v(": "),t("code",[e._v("Tensor")]),e._v(" of type "),t("code",[e._v("float16")]),e._v(", "),t("code",[e._v("float32")]),e._v(", "),t("code",[e._v("float64")]),e._v(", "),t("code",[e._v("int32")]),e._v(", "),t("code",[e._v("complex64")]),e._v(", "),t("code",[e._v("complex128")]),e._v(" "),t("code",[e._v("a")]),e._v("nd r"),t("code",[e._v("a")]),e._v("nk > 1.")]),e._v(" "),t("li",[t("code",[e._v("b")]),e._v(": "),t("code",[e._v("Tensor")]),e._v(" with s"),t("code",[e._v("a")]),e._v("me type "),t("code",[e._v("a")]),e._v("nd r"),t("code",[e._v("a")]),e._v("nk = r"),t("code",[e._v("a")]),e._v("nk("),t("code",[e._v("a")]),e._v(") - 1.")]),e._v(" "),t("li",[t("code",[e._v("transpose_a")]),e._v(": If "),t("code",[e._v("True")]),e._v(", "),t("code",[e._v("a")]),e._v(" is tr"),t("code",[e._v("a")]),e._v("nsposed "),t("code",[e._v("b")]),e._v("efore multiplic"),t("code",[e._v("a")]),e._v("tion.")]),e._v(" "),t("li",[t("code",[e._v("a")]),e._v("djoint_"),t("code",[e._v("a")]),e._v(": If "),t("code",[e._v("True")]),e._v(", "),t("code",[e._v("a")]),e._v(" is conjug"),t("code",[e._v("a")]),e._v("ted "),t("code",[e._v("a")]),e._v("nd tr"),t("code",[e._v("a")]),e._v("nsposed "),t("code",[e._v("b")]),e._v("efore multiplic"),t("code",[e._v("a")]),e._v("tion.")]),e._v(" "),t("li",[t("code",[e._v("a")]),e._v("_is_sp"),t("code",[e._v("a")]),e._v("rse: If "),t("code",[e._v("True")]),e._v(", "),t("code",[e._v("a")]),e._v(" is tre"),t("code",[e._v("a")]),e._v("ted "),t("code",[e._v("a")]),e._v("s "),t("code",[e._v("a")]),e._v(" sp"),t("code",[e._v("a")]),e._v("rse m"),t("code",[e._v("a")]),e._v("trix.")]),e._v(" "),t("li",[t("code",[e._v("b")]),e._v("_is_sp"),t("code",[e._v("a")]),e._v("rse: If "),t("code",[e._v("True")]),e._v(", "),t("code",[e._v("b")]),e._v(" is tre"),t("code",[e._v("a")]),e._v("ted "),t("code",[e._v("a")]),e._v("s "),t("code",[e._v("a")]),e._v(" sp"),t("code",[e._v("a")]),e._v("rse m"),t("code",[e._v("a")]),e._v("trix.")]),e._v(" "),t("li",[t("code",[e._v("name")]),e._v(": N"),t("code",[e._v("a")]),e._v("me for the oper"),t("code",[e._v("a")]),e._v("tion (option"),t("code",[e._v("a")]),e._v("l).")])]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),t("p",[e._v("A Tensor of the same type as a and b where each inner-most vector is the product of the corresponding matrices in a and vectors in b, e.g. if all transpose or adjoint attributes are False:")]),e._v(" "),t("p",[e._v("output[..., i] = sum_k (a[..., i, k] * b[..., k]), for all indices i.")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Note")]),e._v(": This is matrix-vector product, not element-wise product.")])]),e._v(" "),t("h4",{attrs:{id:"raises"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("ValueError")]),e._v(": If transpose_a and adjoint_a are both set to True.")])])])}),[],!1,null,null,null);a.default=s.exports}}]);