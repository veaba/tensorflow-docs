(window.webpackJsonp=window.webpackJsonp||[]).push([[2389],{2577:function(e,t,s){"use strict";s.r(t);var n=s(0),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("Defined in generated file: python/ops/gen_string_ops.py")]),e._v(" "),s("p",[e._v("Joins the elements of inputs based on segment_ids.")]),e._v(" "),s("h3",{attrs:{id:"aliases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("tf.compat.v1.strings.unsorted_segment_join")])]),e._v(" "),s("li",[s("code",[e._v("tf.compat.v2.strings.unsorted_segment_join")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" tf.strings.unsorted_segment_join(\n    inputs,\n    segment_ids,\n    num_segments,\n    separator='',\n    name=None\n)\n")])])]),s("p",[e._v("Computes the string join along segments of a tensor. Given segment_ids with rank N and data with rank N+M:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" `output[i, k1...kM] = strings.join([data[j1...jN, k1...kM])`\n")])])]),s("p",[e._v("where the join is over all [j1...jN] such that segment_ids[j1...jN] = i. Strings are joined in row-major order.")]),e._v(" "),s("h4",{attrs:{id:"for-example"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#for-example","aria-hidden":"true"}},[e._v("#")]),e._v(" For example:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" inputs = [['Y', 'q', 'c'], ['Y', '6', '6'], ['p', 'G', 'a']]\noutput_array = string_ops.unsorted_segment_join(inputs=inputs,\n                                                segment_ids=[1, 0, 1],\n                                                num_segments=2,\n                                                separator=':'))\n# output_array ==> [['Y', '6', '6'], ['Y:p', 'q:G', 'c:a']]\n\n\ninputs = ['this', 'is', 'a', 'test']\noutput_array = string_ops.unsorted_segment_join(inputs=inputs,\n                                                segment_ids=[0, 0, 0, 0],\n                                                num_segments=1,\n                                                separator=':'))\n# output_array ==> ['this:is:a:test']\n")])])]),s("h4",{attrs:{id:"args"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("inputs")]),e._v(": A "),s("code",[e._v("Tensor")]),e._v(" of type "),s("code",[e._v("string")]),e._v(". The input to be joined.")]),e._v(" "),s("li",[s("code",[e._v("segment_ids")]),e._v(": A "),s("code",[e._v("Tensor")]),e._v(". Must be one of the following types: "),s("code",[e._v("int32")]),e._v(", "),s("code",[e._v("int64")]),e._v(". A tensor whose shape is a prefix of data.shape. Negative segment ids are not supported.")]),e._v(" "),s("li",[s("code",[e._v("num_segments")]),e._v(": A "),s("code",[e._v("Tensor")]),e._v(". Must be one of the following types: "),s("code",[e._v("int32")]),e._v(", "),s("code",[e._v("int64")]),e._v(". A scalar.")]),e._v(" "),s("li",[s("code",[e._v("separator")]),e._v(": An optional "),s("code",[e._v("string")]),e._v(". Defaults to "),s("code",[e._v('""')]),e._v(". The "),s("code",[e._v("separator")]),e._v(" to use when joining.")]),e._v(" "),s("li",[s("code",[e._v("name")]),e._v(": A "),s("code",[e._v("name")]),e._v(" for the operation (optional).")])]),e._v(" "),s("h4",{attrs:{id:"returns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),s("p",[e._v("A Tensor of type string.")])])}),[],!1,null,null,null);t.default=a.exports}}]);