(window.webpackJsonp=window.webpackJsonp||[]).push([[2604],{2795:function(e,t,o){"use strict";o.r(t);var v=o(0),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("Tr"),o("code",[e._v("a")]),e._v("nsposes "),o("code",[e._v("a")]),e._v(".")]),e._v(" "),o("h3",{attrs:{id:"aliases"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("tf.compat.v2.transpose")])])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v(" tf.transpose(\n    a,\n    perm=None,\n    conjugate=False,\n    name='transpose'\n)\n")])])]),o("h3",{attrs:{id:"used-in-the-tutorials"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#used-in-the-tutorials","aria-hidden":"true"}},[e._v("#")]),e._v(" Used in the tutorials:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("B")]),e._v("e"),o("code",[e._v("t")]),e._v("t"),o("code",[e._v("e")]),e._v("r"),o("code"),e._v("p"),o("code",[e._v("e")]),e._v("r"),o("code",[e._v("f")]),e._v("o"),o("code",[e._v("r")]),e._v("m"),o("code",[e._v("a")]),e._v("n"),o("code",[e._v("c")]),e._v("e"),o("code"),e._v("w"),o("code",[e._v("i")]),e._v("t"),o("code",[e._v("h")]),e._v(" "),o("code",[e._v("t")]),e._v("f"),o("code",[e._v(".")]),e._v("f"),o("code",[e._v("u")]),e._v("n"),o("code",[e._v("c")]),e._v("t"),o("code",[e._v("i")]),e._v("o"),o("code",[e._v("n")])]),e._v(" "),o("li",[o("code",[e._v("T")]),e._v("r"),o("code",[e._v("a")]),e._v("n"),o("code",[e._v("s")]),e._v("f"),o("code",[e._v("o")]),e._v("r"),o("code",[e._v("m")]),e._v("e"),o("code",[e._v("r")]),e._v(" "),o("code",[e._v("m")]),e._v("o"),o("code",[e._v("d")]),e._v("e"),o("code",[e._v("l")]),e._v(" "),o("code",[e._v("f")]),e._v("o"),o("code",[e._v("r")]),e._v(" "),o("code",[e._v("l")]),e._v("a"),o("code",[e._v("n")]),e._v("g"),o("code",[e._v("u")]),e._v("a"),o("code",[e._v("g")]),e._v("e"),o("code"),e._v("u"),o("code",[e._v("n")]),e._v("d"),o("code",[e._v("e")]),e._v("r"),o("code",[e._v("s")]),e._v("t"),o("code",[e._v("a")]),e._v("n"),o("code",[e._v("d")]),e._v("i"),o("code",[e._v("n")]),e._v("g``\nPermutes the dimensions according to "),o("code",[e._v("perm")]),e._v(".\nThe returned tensor's dimension i will correspond to the input dimension "),o("code",[e._v("perm[i]")]),e._v(". If "),o("code",[e._v("perm")]),e._v(" is not given, it is set to (n-1...0), where n is the r"),o("code",[e._v("a")]),e._v("nk of the input tensor. Hence by def"),o("code",[e._v("a")]),e._v("ult, this oper"),o("code",[e._v("a")]),e._v("tion performs "),o("code",[e._v("a")]),e._v(" regul"),o("code",[e._v("a")]),e._v("r m"),o("code",[e._v("a")]),e._v("trix tr"),o("code",[e._v("a")]),e._v("nspose on 2-D input Tensors. If conjug"),o("code",[e._v("a")]),e._v("te is True "),o("code",[e._v("a")]),e._v("nd "),o("code",[e._v("a.dtype")]),e._v(" is either "),o("code",[e._v("complex64")]),e._v(" or "),o("code",[e._v("complex128")]),e._v(" then the v"),o("code",[e._v("a")]),e._v("lues of "),o("code",[e._v("a")]),e._v(" "),o("code",[e._v("a")]),e._v("re conjug"),o("code",[e._v("a")]),e._v("ted "),o("code",[e._v("a")]),e._v("nd tr"),o("code",[e._v("a")]),e._v("nsposed.")])]),e._v(" "),o("h4",{attrs:{id:"for-example"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#for-example","aria-hidden":"true"}},[e._v("#")]),e._v(" For example:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v(" x = tf.constant([[1, 2, 3], [4, 5, 6]])\ntf.transpose(x)  # [[1, 4]\n                 #  [2, 5]\n                 #  [3, 6]]\n\n# Equivalently\ntf.transpose(x, perm=[1, 0])  # [[1, 4]\n                              #  [2, 5]\n                              #  [3, 6]]\n\n# If x is complex, setting conjugate=True gives the conjugate transpose\nx = tf.constant([[1 + 1j, 2 + 2j, 3 + 3j],\n                 [4 + 4j, 5 + 5j, 6 + 6j]])\ntf.transpose(x, conjugate=True)  # [[1 - 1j, 4 - 4j],\n                                 #  [2 - 2j, 5 - 5j],\n                                 #  [3 - 3j, 6 - 6j]]\n\n# 'perm' is more useful for n-dimensional tensors, for n > 2\nx = tf.constant([[[ 1,  2,  3],\n                  [ 4,  5,  6]],\n                 [[ 7,  8,  9],\n                  [10, 11, 12]]])\n\n# Take the transpose of the matrices in dimension-0\n# (this common operation has a shorthand `linalg.matrix_transpose`)\ntf.transpose(x, perm=[0, 2, 1])  # [[[1,  4],\n                                 #   [2,  5],\n                                 #   [3,  6]],\n                                 #  [[7, 10],\n                                 #   [8, 11],\n                                 #   [9, 12]]]\n")])])]),o("h4",{attrs:{id:"args"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("a")]),e._v(": A "),o("code",[e._v("Tensor")]),e._v(".")]),e._v(" "),o("li",[o("code",[e._v("perm")]),e._v(": A "),o("code",[e._v("perm")]),e._v("ut"),o("code",[e._v("a")]),e._v("tion of the dimensions of "),o("code",[e._v("a")]),e._v(".")]),e._v(" "),o("li",[o("code",[e._v("conjugate")]),e._v(": Option"),o("code",[e._v("a")]),e._v("l bool. Setting it to "),o("code",[e._v("True")]),e._v(" is m"),o("code",[e._v("a")]),e._v("them"),o("code",[e._v("a")]),e._v("tic"),o("code",[e._v("a")]),e._v("lly equiv"),o("code",[e._v("a")]),e._v("lent to tf.m"),o("code",[e._v("a")]),e._v("th.conj(tf.tr"),o("code",[e._v("a")]),e._v("nspose(input)).")]),e._v(" "),o("li",[o("code",[e._v("name")]),e._v(": A "),o("code",[e._v("name")]),e._v(" for the oper"),o("code",[e._v("a")]),e._v("tion (option"),o("code",[e._v("a")]),e._v("l).")])]),e._v(" "),o("h4",{attrs:{id:"returns"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),o("p",[e._v("A transposed "),o("code",[e._v("Tensor")]),e._v(".")]),e._v(" "),o("h4",{attrs:{id:"numpy-compatibility"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#numpy-compatibility","aria-hidden":"true"}},[e._v("#")]),e._v(" Numpy Compatibility")]),e._v(" "),o("p",[e._v("In "),o("code",[e._v("numpy")]),e._v(" transposes are memory-efficient constant time operations as they simply return a new view of the same data with adjusted "),o("code",[e._v("strides")]),e._v(".\nTensorFlow does not support strides, so "),o("code",[e._v("transpose")]),e._v(" returns a new tensor with the items permuted.")])])}),[],!1,null,null,null);t.default=_.exports}}]);