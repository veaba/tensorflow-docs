(window.webpackJsonp=window.webpackJsonp||[]).push([[2505],{2696:function(e,a,t){"use strict";t.r(a);var s=t(0),o=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Defined in generated file: "),t("code",[e._v("python/ops/gen_array_ops.py")]),e._v("\nBroadcast an array for a compatible shape.")]),e._v(" "),t("h3",{attrs:{id:"aliases"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("tf.compat.v1.broadcast_to")])]),e._v(" "),t("li",[t("code",[e._v("tf.compat.v2.broadcast_to")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" tf.broadcast_to(\n    input,\n    shape,\n    name=None\n)\n")])])]),t("p",[e._v("Broadcasting is the process of making arrays to have compatible shapes for arithmetic operations. Two shapes are compatible if for each dimension pair they are either equal or one of them is one. When trying to broadcast a Tensor to a shape, it starts with the trailing dimensions, and works its way forward.\nFor example,")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" x = tf.constant([1, 2, 3])\ny = tf.broadcast_to(x, [3, 3])\nsess.run(y)\narray([[1, 2, 3],\n       [1, 2, 3],\n       [1, 2, 3]], dtype=int32)\n")])])]),t("p",[e._v("In the above example, the input Tensor with the shape of "),t("code",[e._v("[1, 3]")]),e._v(" is broadcasted to output Tensor with shape of "),t("code",[e._v("[3, 3]")]),e._v(".")]),e._v(" "),t("h4",{attrs:{id:"args"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("input")]),e._v(": A "),t("code",[e._v("Tensor")]),e._v(". A "),t("code",[e._v("Tensor")]),e._v(" to broadcast.")]),e._v(" "),t("li",[t("code",[e._v("shape")]),e._v(": A "),t("code",[e._v("Tensor")]),e._v(". Must be one of the following types: "),t("code",[e._v("int32")]),e._v(", "),t("code",[e._v("int64")]),e._v(". An 1-D "),t("code",[e._v("int")]),e._v(" "),t("code",[e._v("Tensor")]),e._v(". The "),t("code",[e._v("shape")]),e._v(" of the desired output.")]),e._v(" "),t("li",[t("code",[e._v("name")]),e._v(": A "),t("code",[e._v("name")]),e._v(" for the operation (optional).")])]),e._v(" "),t("h4",{attrs:{id:"returns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),t("p",[e._v("A "),t("code",[e._v("Tensor")]),e._v(". Has the same type as "),t("code",[e._v("input")]),e._v(".")])])}),[],!1,null,null,null);a.default=o.exports}}]);