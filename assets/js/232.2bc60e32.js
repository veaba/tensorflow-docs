(window.webpackJsonp=window.webpackJsonp||[]).push([[232],{420:function(e,n,t){"use strict";t.r(n);var s=t(0),a=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("In TensorFlow 2.0, iterating over a TensorShape instance returns values.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" tf.compat.v1.enable_v2_tensorshape()\n")])])]),t("p",[e._v("This enables the new behavior.")]),e._v(" "),t("p",[e._v("Concretely, tensor_shape[i] returned a Dimension instance in V1, but it V2 it returns either an integer, or None.")]),e._v(" "),t("h4",{attrs:{id:"examples"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#examples","aria-hidden":"true"}},[e._v("#")]),e._v(" Examples:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" #######################\n# If you had this in V1:\nvalue = tensor_shape[i].value\n\n# Do this in V2 instead:\nvalue = tensor_shape[i]\n\n#######################\n# If you had this in V1:\nfor dim in tensor_shape:\n  value = dim.value\n  print(value)\n\n# Do this in V2 instead:\nfor value in tensor_shape:\n  print(value)\n\n#######################\n# If you had this in V1:\ndim = tensor_shape[i]\ndim.assert_is_compatible_with(other_shape)  # or using any other shape method\n\n# Do this in V2 instead:\nif tensor_shape.rank is None:\n  dim = Dimension(None)\nelse:\n  dim = tensor_shape.dims[i]\ndim.assert_is_compatible_with(other_shape)  # or using any other shape method\n\n# The V2 suggestion above is more explicit, which will save you from\n# the following trap (present in V1):\n# you might do in-place modifications to `dim` and expect them to be reflected\n# in `tensor_shape[i]`, but they would not be.\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);