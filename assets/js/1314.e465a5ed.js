(window.webpackJsonp=window.webpackJsonp||[]).push([[1314],{1503:function(e,t,n){"use strict";n.r(t);var a=n(0),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("DenseColumn that converts from sparse, categorical input.")]),e._v(" "),n("h3",{attrs:{id:"aliases"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("tf.compat.v1.feature_column.embedding_column")])]),e._v(" "),n("li",[n("code",[e._v("tf.compat.v2.feature_column.embedding_column")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" tf.feature_column.embedding_column(\n    categorical_column,\n    dimension,\n    combiner='mean',\n    initializer=None,\n    ckpt_to_load_from=None,\n    tensor_name_in_ckpt=None,\n    max_norm=None,\n    trainable=True\n)\n")])])]),n("h3",{attrs:{id:"used-in-the-tutorials"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#used-in-the-tutorials","aria-hidden":"true"}},[e._v("#")]),e._v(" Used in the tutorials:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("C")]),e._v("l"),n("code",[e._v("a")]),e._v("s"),n("code",[e._v("s")]),e._v("i"),n("code",[e._v("f")]),e._v("y"),n("code"),e._v("s"),n("code",[e._v("t")]),e._v("r"),n("code",[e._v("u")]),e._v("c"),n("code",[e._v("t")]),e._v("u"),n("code",[e._v("r")]),e._v("e"),n("code",[e._v("d")]),e._v(" "),n("code",[e._v("d")]),e._v("a"),n("code",[e._v("t")]),e._v("a"),n("code"),e._v("w"),n("code",[e._v("i")]),e._v("t"),n("code",[e._v("h")]),e._v(" "),n("code",[e._v("f")]),e._v("e"),n("code",[e._v("a")]),e._v("t"),n("code",[e._v("u")]),e._v("r"),n("code",[e._v("e")]),e._v(" "),n("code",[e._v("c")]),e._v("o"),n("code",[e._v("l")]),e._v("u"),n("code",[e._v("m")]),e._v("n"),n("code",[e._v("s")])])]),e._v(" "),n("p",[e._v("Use this when your inputs are sparse, but you want to convert them to a dense representation (e.g., to feed to a DNN).")]),e._v(" "),n("p",[e._v("Inputs must be a CategoricalColumn created by any of the categorical_column_* function. Here is an example of using embedding_column with DNNClassifier:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" video_id = categorical_column_with_identity(\n    key='video_id', num_buckets=1000000, default_value=0)\ncolumns = [embedding_column(video_id, 9),...]\n\nestimator = tf.estimator.DNNClassifier(feature_columns=columns, ...)\n\nlabel_column = ...\ndef input_fn():\n  features = tf.io.parse_example(\n      ..., features=make_parse_example_spec(columns + [label_column]))\n  labels = features.pop(label_column.name)\n  return features, labels\n\nestimator.train(input_fn=input_fn, steps=100)\n")])])]),n("p",[e._v("Here is an example using embedding_column with model_fn:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" def model_fn(features, ...):\n  video_id = categorical_column_with_identity(\n      key='video_id', num_buckets=1000000, default_value=0)\n  columns = [embedding_column(video_id, 9),...]\n  dense_tensor = input_layer(features, columns)\n  # Form DNN layers, calculate loss, and return EstimatorSpec.\n  ...\n")])])]),n("h4",{attrs:{id:"args"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("categorical_column")]),e._v(": A "),n("code",[e._v("CategoricalColumn")]),e._v(" created by a "),n("code",[e._v("categorical_column")]),n("em",[e._v("with")]),e._v("* function. This column produces the sparse IDs that are inputs to the embedding lookup.")]),e._v(" "),n("li",[n("code",[e._v("dimension")]),e._v(": An integer specifying "),n("code",[e._v("dimension")]),e._v(" of the embedding, must be > 0.")]),e._v(" "),n("li",[n("code",[e._v("combiner")]),e._v(": A string specifying how to reduce if there are multiple entries in a single row. Currently 'mean', 'sqrtn' and 'sum' are supported, with 'mean' the default. 'sqrtn' often achieves good accuracy, in particular with bag-of-words columns. Each of this can be thought as example level normalizations on the column. For more information, see "),n("code",[e._v("tf.embedding_lookup_sparse")]),e._v(".")]),e._v(" "),n("li",[n("code",[e._v("initializer")]),e._v(": A variable "),n("code",[e._v("initializer")]),e._v(" function to be used in embedding variable initialization. If not specified, defaults to "),n("code",[e._v("truncated_normal_initializer")]),e._v(" with mean "),n("code",[e._v("0.0")]),e._v(" and standard deviation 1/sqrt("),n("code",[e._v("dimension")]),e._v(").")]),e._v(" "),n("li",[n("code",[e._v("ckpt_to_load_from")]),e._v(": String representing checkpoint name/pattern from which to restore column weights. Required if "),n("code",[e._v("tensor_name_in_ckpt")]),e._v(" is not "),n("code",[e._v("None")]),e._v(".")]),e._v(" "),n("li",[n("code",[e._v("tensor_name_in_ckpt")]),e._v(": Name of the "),n("code",[e._v("Tensor")]),e._v(" in "),n("code",[e._v("ckpt_to_load_from")]),e._v(" from which to restore the column weights. Required if "),n("code",[e._v("ckpt_to_load_from")]),e._v(" is not "),n("code",[e._v("None")]),e._v(".")]),e._v(" "),n("li",[n("code",[e._v("max_norm")]),e._v(": If not "),n("code",[e._v("None")]),e._v(", embedding values are l2-normalized to this value.")]),e._v(" "),n("li",[n("code",[e._v("trainable")]),e._v(": Whether or not the embedding is "),n("code",[e._v("trainable")]),e._v(". Default is True.")])]),e._v(" "),n("h4",{attrs:{id:"returns"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),n("p",[e._v("DenseColumn that converts from sparse input.")]),e._v(" "),n("h4",{attrs:{id:"raises"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("ValueError")]),e._v(": if "),n("code",[e._v("dimension")]),e._v(" not > 0.")]),e._v(" "),n("li",[n("code",[e._v("ValueError")]),e._v(": if exactly one of "),n("code",[e._v("ckpt_to_load_from")]),e._v(" and "),n("code",[e._v("tensor_name_in_ckpt")]),e._v(" is specified.")]),e._v(" "),n("li",[n("code",[e._v("ValueError")]),e._v(": if "),n("code",[e._v("initializer")]),e._v(" is specified and is not callable.")]),e._v(" "),n("li",[n("code",[e._v("RuntimeError")]),e._v(": If eager execution is enabled.")])])])}),[],!1,null,null,null);t.default=o.exports}}]);