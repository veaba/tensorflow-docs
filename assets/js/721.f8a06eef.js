(window.webpackJsonp=window.webpackJsonp||[]).push([[721],{909:function(e,n,s){"use strict";s.r(n);var t=s(0),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("Joins a string Tensor across the given dimensions.")]),e._v(" "),s("h3",{attrs:{id:"aliases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("tf.compat.v1.strings.reduce_join")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" tf.compat.v1.reduce_join(\n    inputs,\n    axis=None,\n    keep_dims=None,\n    separator='',\n    name=None,\n    reduction_indices=None,\n    keepdims=None\n)\n")])])]),s("p",[e._v("Computes the string join across dimensions in the given string Tensor of shape [\\(d_0, d_1, ..., d_{n-1}\\)]. Returns a new Tensor created by joining the input strings with the given separator (default: empty string). Negative indices are counted backwards from the end, with -1 being equivalent to n - 1. If indices are not specified, joins across all dimensions beginning from n - 1 through 0.")]),e._v(" "),s("h4",{attrs:{id:"for-example"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#for-example","aria-hidden":"true"}},[e._v("#")]),e._v(" For example:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(' # tensor `a` is [["a", "b"], ["c", "d"]]\ntf.strings.reduce_join(a, 0) ==> ["ac", "bd"]\ntf.strings.reduce_join(a, 1) ==> ["ab", "cd"]\ntf.strings.reduce_join(a, -2) = tf.strings.reduce_join(a, 0) ==> ["ac", "bd"]\ntf.strings.reduce_join(a, -1) = tf.strings.reduce_join(a, 1) ==> ["ab", "cd"]\ntf.strings.reduce_join(a, 0, keep_dims=True) ==> [["ac", "bd"]]\ntf.strings.reduce_join(a, 1, keep_dims=True) ==> [["ab"], ["cd"]]\ntf.strings.reduce_join(a, 0, separator=".") ==> ["a.c", "b.d"]\ntf.strings.reduce_join(a, [0, 1]) ==> "acbd"\ntf.strings.reduce_join(a, [1, 0]) ==> "abcd"\ntf.strings.reduce_join(a, []) ==> [["a", "b"], ["c", "d"]]\ntf.strings.reduce_join(a) = tf.strings.reduce_join(a, [1, 0]) ==> "abcd"\n')])])]),s("h4",{attrs:{id:"args"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("inputs")]),e._v(": A "),s("code",[e._v("Tensor")]),e._v(" of type "),s("code",[e._v("string")]),e._v(". The input to be joined. All reduced indices must have non-zero size.")])]),e._v(" "),s("h4",{attrs:{id:"returns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),s("p",[e._v("A Tensor of type string.")])])}),[],!1,null,null,null);n.default=a.exports}}]);