(window.webpackJsonp=window.webpackJsonp||[]).push([[2260],{2448:function(a,e,n){"use strict";n.r(e);var t=n(0),i=Object(t.a)({},(function(){var a=this,e=a.$createElement,n=a._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("p",[a._v("Defined in generated file: python/ops/gen_array_ops.py")]),a._v(" "),n("p",[a._v("Fake-quantize the 'inputs' tensor of type float and one of the shapes: [d],")]),a._v(" "),n("h3",{attrs:{id:"aliases"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[a._v("#")]),a._v(" Aliases:")]),a._v(" "),n("ul",[n("li",[n("code",[a._v("tf.compat.v1.fake_quant_with_min_max_vars_per_channel")])]),a._v(" "),n("li",[n("code",[a._v("tf.compat.v1.quantization.fake_quant_with_min_max_vars_per_channel")])]),a._v(" "),n("li",[n("code",[a._v("tf.compat.v2.quantization.fake_quant_with_min_max_vars_per_channel")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v(" tf.quantization.fake_quant_with_min_max_vars_per_channel(\n    inputs,\n    min,\n    max,\n    num_bits=8,\n    narrow_range=False,\n    name=None\n)\n")])])]),n("p",[a._v("[b, d] [b, h, w, d] via per-channel floats min and max of shape [d] to 'outputs' tensor of same shape as inputs.")]),a._v(" "),n("p",[a._v("[min; max] define the clamping range for the inputs data. inputs values are quantized into the quantization range ([0; 2^num_bits - 1] when narrow_range is false and [1; 2^num_bits - 1] when it is true) and then de-quantized and output as floats in [min; max] interval. num_bits is the bitwidth of the quantization; between 2 and 16, inclusive.")]),a._v(" "),n("p",[a._v("Before quantization, min and max values are adjusted with the following logic. It is suggested to have min <= 0 <= max. If 0 is not in the range of values, the behavior can be unexpected: If 0 < min < max: min_adj = 0 and max_adj = max - min. If min < max < 0: min_adj = min - max and max_adj = 0. If min <= 0 <= max: scale = (max - min) / (2^num_bits - 1), min_adj = scale * round(min / scale) and max_adj = max + min_adj - min.")]),a._v(" "),n("p",[a._v("This operation has a gradient and thus allows for training min and max values.")]),a._v(" "),n("h4",{attrs:{id:"args"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[a._v("#")]),a._v(" Args:")]),a._v(" "),n("ul",[n("li",[n("code",[a._v("inputs")]),a._v(": A "),n("code",[a._v("Tensor")]),a._v(" of type "),n("code",[a._v("float32")]),a._v(".")]),a._v(" "),n("li",[n("code",[a._v("min")]),a._v(": A "),n("code",[a._v("Tensor")]),a._v(" of type "),n("code",[a._v("float32")]),a._v(".")]),a._v(" "),n("li",[n("code",[a._v("max")]),a._v(": A "),n("code",[a._v("Tensor")]),a._v(" of type "),n("code",[a._v("float32")]),a._v(".")]),a._v(" "),n("li",[n("code",[a._v("num_bits")]),a._v(": An optional "),n("code",[a._v("int")]),a._v(". Defaults to "),n("code",[a._v("8")]),a._v(".")]),a._v(" "),n("li",[n("code",[a._v("narrow_range")]),a._v(": An optional "),n("code",[a._v("bool")]),a._v(". Defaults to "),n("code",[a._v("False")]),a._v(".")]),a._v(" "),n("li",[n("code",[a._v("name")]),a._v(": A "),n("code",[a._v("name")]),a._v(" for the operation (optional).")])]),a._v(" "),n("h4",{attrs:{id:"returns"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[a._v("#")]),a._v(" Returns:")]),a._v(" "),n("p",[a._v("A Tensor of type float32.")])])}),[],!1,null,null,null);e.default=i.exports}}]);