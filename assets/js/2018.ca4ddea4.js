(window.webpackJsonp=window.webpackJsonp||[]).push([[2018],{2209:function(e,t,o){"use strict";o.r(t);var a=o(0),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("Defined in generated file: python/ops/gen_linalg_ops.py")]),e._v(" "),o("p",[e._v("Computes the LU decomposition of one or more square matrices.")]),e._v(" "),o("h3",{attrs:{id:"aliases"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#aliases","aria-hidden":"true"}},[e._v("#")]),e._v(" Aliases:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("tf.compat.v1.linalg.lu")])]),e._v(" "),o("li",[o("code",[e._v("tf.compat.v2.linalg.lu")])])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v(" tf.linalg.lu(\n    input,\n    output_idx_type=tf.dtypes.int32,\n    name=None\n)\n")])])]),o("p",[e._v("The input is a tensor of shape [..., M, M] whose inner-most 2 dimensions form square matrices.")]),e._v(" "),o("p",[e._v("The input has to be invertible.")]),e._v(" "),o("p",[e._v("The output consists of two tensors LU and P containing the LU decomposition of all input submatrices [..., :, :]. LU encodes the lower triangular and upper triangular factors.")]),e._v(" "),o("p",[e._v("For each input submatrix of shape [M, M], L is a lower triangular matrix of shape [M, M] with unit diagonal whose entries correspond to the strictly lower triangular part of LU. U is a upper triangular matrix of shape [M, M] whose entries correspond to the upper triangular part, including the diagonal, of LU.")]),e._v(" "),o("p",[e._v("P represents a permutation matrix encoded as a list of indices each between 0 and M-1, inclusive. If P_mat denotes the permutation matrix corresponding to P, then the L, U and P satisfies P_mat * input = L * U.")]),e._v(" "),o("h4",{attrs:{id:"args"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("input")]),e._v(":"),o("code"),e._v("A"),o("code",[e._v("``Tensor``.`` ``M")]),e._v("ust"),o("code"),e._v("be"),o("code"),e._v("one"),o("code"),e._v("of"),o("code"),e._v("the"),o("code"),e._v("following"),o("code"),e._v("types:"),o("code",[e._v("``float64``,`` ``float32``,`` ``half``,`` ``complex64``,`` ``complex128``.``")]),e._v("A"),o("code"),e._v("tensor"),o("code"),e._v("of"),o("code"),e._v("shape"),o("code"),e._v("["),o("code",[e._v(".``.``.``,`` ``M``,`` ``M")]),e._v("]"),o("code"),e._v("whose"),o("code"),e._v("inner-most"),o("code"),e._v("2"),o("code"),e._v("dimensions"),o("code"),e._v("form"),o("code"),e._v("matrices"),o("code"),e._v("of"),o("code"),e._v("size"),o("code"),e._v("["),o("code",[e._v("M``,`` ``M")]),e._v("]"),o("code",[e._v(".")])]),e._v(" "),o("li",[o("code",[e._v("output_idx_type")]),e._v(":"),o("code"),e._v("An"),o("code"),e._v("optional"),o("code",[e._v("``tf.DType``")]),e._v("from:"),o("code",[e._v("``tf.int32, tf.int64``.``")]),e._v("Defaults"),o("code"),e._v("to"),o("code",[e._v("``tf.int32``.")])]),e._v(" "),o("li",[o("code",[e._v("name")]),e._v(":"),o("code"),e._v("A"),o("code",[e._v("``name``")]),e._v("for"),o("code"),e._v("the"),o("code"),e._v("operation"),o("code"),e._v("(optional)"),o("code",[e._v(".")])])]),e._v(" "),o("h4",{attrs:{id:"returns"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),o("p",[e._v("A tuple of Tensor objects (lu, p).")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("lu")]),e._v(": A "),o("code",[e._v("Tensor")]),e._v(". Has the same type as "),o("code",[e._v("input")]),e._v(".")]),e._v(" "),o("li",[o("code",[e._v("p")]),e._v(": A "),o("code",[e._v("Tensor")]),e._v(" of ty"),o("code",[e._v("p")]),e._v("e "),o("code",[e._v("output_idx_type")]),e._v(".")])])])}),[],!1,null,null,null);t.default=s.exports}}]);