(window.webpackJsonp=window.webpackJsonp||[]).push([[149],{337:function(e,t,n){"use strict";n.r(t);var a=n(0),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Converts the given value to a Tensor.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" tf.compat.v1.convert_to_tensor(\n    value,\n    dtype=None,\n    name=None,\n    preferred_dtype=None,\n    dtype_hint=None\n)\n")])])]),n("p",[e._v("This function converts Python objects of various types to Tensor objects. It accepts Tensor objects, numpy arrays, Python lists, and Python scalars. For example:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" import numpy as np\n\ndef my_func(arg):\n  arg = tf.convert_to_tensor(arg, dtype=tf.float32)\n  return tf.matmul(arg, arg) + arg\n\n# The following calls are equivalent.\nvalue_1 = my_func(tf.constant([[1.0, 2.0], [3.0, 4.0]]))\nvalue_2 = my_func([[1.0, 2.0], [3.0, 4.0]])\nvalue_3 = my_func(np.array([[1.0, 2.0], [3.0, 4.0]], dtype=np.float32))\n")])])]),n("p",[e._v("This function can be useful when composing a new operation in Python (such as my_func in the example above). All standard Python op constructors apply this function to each of their Tensor-valued inputs, which allows those ops to accept numpy arrays, Python lists, and scalars in addition to Tensor objects.")]),e._v(" "),n("h4",{attrs:{id:"args"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#args","aria-hidden":"true"}},[e._v("#")]),e._v(" Args:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("value")]),e._v(": An object whose type has a registered "),n("code",[e._v("Tensor")]),e._v(" conversion function.")]),e._v(" "),n("li",[n("code",[e._v("dtype")]),e._v(": Optional element type for the returned tensor. If missing, the type is inferred from the type of "),n("code",[e._v("value")]),e._v(".")]),e._v(" "),n("li",[n("code",[e._v("name")]),e._v(": Optional "),n("code",[e._v("name")]),e._v(" to use if a new "),n("code",[e._v("Tensor")]),e._v(" is created.")]),e._v(" "),n("li",[n("code",[e._v("preferred_dtype")]),e._v(": Optional element type for the returned tensor, used when "),n("code",[e._v("dtype")]),e._v(" is None. In some cases, a caller may not have a "),n("code",[e._v("dtype")]),e._v(" in mind when converting to a tensor, so "),n("code",[e._v("preferred_dtype")]),e._v(" can be used as a soft preference. If the conversion to "),n("code",[e._v("preferred_dtype")]),e._v(" is not possible, this argument has no effect.")]),e._v(" "),n("li",[n("code",[e._v("dtype")]),e._v("_hint: same meaning as "),n("code",[e._v("preferred_dtype")]),e._v(", and overrides it.")])]),e._v(" "),n("h4",{attrs:{id:"returns"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#returns","aria-hidden":"true"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),n("p",[e._v("A Tensor based on value.")]),e._v(" "),n("h4",{attrs:{id:"raises"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#raises","aria-hidden":"true"}},[e._v("#")]),e._v(" Raises:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("TypeError")]),e._v(": If no conversion function is registered for "),n("code",[e._v("value")]),e._v(" to "),n("code",[e._v("dtype")]),e._v(".")]),e._v(" "),n("li",[n("code",[e._v("RuntimeError")]),e._v(": If a registered conversion function returns an invalid "),n("code",[e._v("value")]),e._v(".")]),e._v(" "),n("li",[n("code",[e._v("ValueError")]),e._v(": If the "),n("code",[e._v("value")]),e._v(" is a tensor not of given "),n("code",[e._v("dtype")]),e._v(" in graph mode.")])])])}),[],!1,null,null,null);t.default=r.exports}}]);